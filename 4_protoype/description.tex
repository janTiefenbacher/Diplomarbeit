In diesem Kapitel wird die technische Umsetzung des Spiels \textit{WoSamma} dokumentiert.
Dabei werden die verwendete Systemumgebung, eingesetzte Technologien sowie die grundlegenden
Konzepte der Implementierung beschrieben, um einen strukturierten Überblick über die Realisierung
der Anwendung zu geben.

\section{Systemumgebung}
Das Spiel WoSamma ist eine mobile Anwendung für iOS und Android und wurde mit React Native und TypeScript entwickelt.
Die Entwicklung erfolgte unter Windows mithilfe von Visual Studio Code.
Für das Veröffentlichen der Anwendung auf iOS-Geräten sowie für abschließende Tests und Fehlerbehebungen wurde Xcode unter macOS in Verbindung mit einem Apple-Developer-Konto verwendet.
Die Tests für Android wurden mit Android Studio auf Emulatoren durchgeführt.
Die Anwendung ist für eine zukünftige Veröffentlichung im Apple App Store sowie im Google Play Store vorgesehen.

\subsection{Verwendete Technologien}
\begin{itemize}
    \item \textbf{React Native} – Framework zur Entwicklung plattformübergreifender mobiler Anwendungen für iOS und Android.
    \item \textbf{TypeScript} – Typsichere Erweiterung von JavaScript, die bewusst anstelle von JavaScript gewählt wurde, um die Wartbarkeit, Lesbarkeit und Codequalität der Anwendung zu erhöhen.
    \item \textbf{Supabase (PostgreSQL)} – Backend-as-a-Service, das zentrale Funktionen wie Authentifizierung, Echtzeitdaten, Datenbankverwaltung sowie eine REST-API bereitstellt und damit den Entwicklungsaufwand deutlich reduziert.
    \item \textbf{Google Maps API} – API zur Verarbeitung und Darstellung geografischer Daten sowie zur Positionsbestimmung innerhalb des Spiels.
    \item \textbf{Google Street View API} – API zur Integration von 360-Grad-Street-View-Bildern aus ganz Österreich, welche die Grundlage für das GeoGuessr-ähnliche Spielkonzept bildet.
    \item \textbf{GitHub} – Plattform zur Versionsverwaltung, die eine strukturierte Zusammenarbeit im Team sowie die kontinuierliche Aktualität des Quellcodes sicherstellt.
    \item \textbf{Jira} – Tool zur Projektplanung und Aufgabenverwaltung, das im Rahmen einer agilen Vorgehensweise für die Diplomarbeit eingesetzt wurde.
    \item \textbf{Figma} – Design- und Prototyping-Tool zur Erstellung von Mockups und interaktiven Prototypen, welche als visuelle Grundlage für die Benutzeroberfläche dienten.
\end{itemize}

\section{Implementierung}
Dieses Kapitel beschreibt die technische Umsetzung des Spiels \textit{WoSamma}. 
Dabei wird auf den Aufbau der Anwendungsarchitektur, die Implementierung des Frontends, 
die Anbindung des Backends sowie auf die zentrale Spiellogik eingegangen. 
Der Fokus liegt auf den verwendeten Konzepten, der Struktur des Quellcodes 
und den getroffenen technischen Entscheidungen.

\subsection{Architektur der Anwendung}
Die Anwendung \textit{WoSamma} folgt einer klaren Trennung zwischen Frontend, Backend 
und externen Diensten. 
Das Frontend wurde mit React Native umgesetzt und ist für die Benutzeroberfläche, 
die Spiellogik sowie die Interaktion mit dem Benutzer verantwortlich.
Das Backend basiert auf Supabase und übernimmt Aufgaben wie Authentifizierung, 
Datenpersistenz und Echtzeitkommunikation.
Externe APIs, wie die Google Maps und Google Street View API, werden zur Bereitstellung 
von geografischen Daten und 360-Grad-Bildern verwendet.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{content/img/4_Technische_Umsetzung/System_Architektur.jpg}
    \caption{Systemarchitektur der Anwendung WoSamma}
    \label{fig:beispielabbildung}
\end{figure}

\subsection{Frontend-Implementierung - JAN NOCH UMSCHREIBEN}
In diesem Abschnitt wird die Umsetzung der Benutzeroberfläche von \textit{WoSamma} beschrieben.
Der Fokus liegt auf der Struktur der Anwendung, der Navigation zwischen verschiedenen Bildschirmen
sowie der Interaktion des Benutzers mit der Spielansicht.
Besonderes Augenmerk liegt dabei auf der Darstellung von Spielinformationen und
der Visualisierung von Spielfortschritten sowohl im Einzelspieler- als auch im Mehrspielermodus.

\subsubsection{Projektstruktur und Navigation}
Die Projektstruktur orientiert sich an bewährten Konzepten von React Native und
TypeScript, um eine modulare, wiederverwendbare und wartbare Codebasis zu gewährleisten.
Die Navigation zwischen den verschiedenen Bildschirmen, wie Startbildschirm, Spielansicht,
Freundeslobby und Profilen, erfolgt über ein Stack- und Tab-basiertes Navigationssystem.
Dieses erlaubt einen intuitiven Zugriff auf alle relevanten Funktionen und stellt sicher,
dass der Benutzer jederzeit den Überblick über den Spielstatus behält.

\subsubsection{Spielansicht und Benutzerinteraktion}
Die Spielansicht bildet das zentrale Interface für den Spieler und ist in Einzelspieler-
und Mehrspielermodus unterteilt.

\paragraph{Einzelspieler-Modus:}
Im Einzelspieler-Modus wird dem Benutzer die korrekte Location sowie die vom Spieler
geratene Position angezeigt.
Die Distanz zwischen der tatsächlichen Location und der gewählten Position wird berechnet
und visualisiert, wodurch der Spieler unmittelbar Feedback zu seiner Genauigkeit erhält.
Zusätzlich werden die Punkte basierend auf dieser Distanz angezeigt, um den Fortschritt
und die Leistung nachvollziehbar zu machen.

\paragraph{Mehrspieler-Modus:}
Im Mehrspieler-Modus werden alle Spieler in einer Lobby zusammengeführt.
Jeder Spieler setzt seine Pins auf der Karte, welche live an alle Teilnehmer übertragen werden.
Zusätzlich wird der richtige Pin angezeigt, um die Vergleichbarkeit der Ergebnisse zu gewährleisten.
Ein Vektor zwischen der geratenen Position jedes Spielers und dem tatsächlichen Standort
wird dargestellt, und die Distanz sowie die erreichten Punkte werden für alle Spieler
übersichtlich angezeigt.
Dies ermöglicht ein direktes, kompetitives Spielerlebnis und fördert die Interaktion
zwischen den Teilnehmern.


\subsection{Backend-Anbindung mit Supabase}
Das Backend der Anwendung \textit{WoSamma} basiert auf Supabase und stellt zentrale Server-Funktionalitäten als \textit{Backend-as-a-Service} bereit. 
Dadurch werden Kernaufgaben wie Authentifizierung, Datenpersistenz sowie Echtzeit-Kommunikation über eine konsistente API abstrahiert. 
Die mobile Anwendung kommuniziert über das Supabase-SDK mit der PostgreSQL-Datenbank und nutzt dabei eine tokenbasierte Zugriffskontrolle. 
Schreib- und Leseoperationen erfolgen ausschließlich innerhalb der durch Supabase bereitgestellten Sicherheitsmechanismen (z.\,B. JWT-basierte Sessions und Row Level Security), wodurch eine klare Trennung zwischen Client-Logik und serverseitiger Datenhaltung gewährleistet wird.

\subsubsection{Echtzeit-Kommunikation über Supabase Channels}
Die Übertragung von Echtzeitdaten erfolgt über sogenannte \emph{Channels}, die als persistente Kommunikationskanäle zwischen Client und Backend fungieren. 
Diese Kanäle können von der Anwendung abonniert (\textit{subscribed}) werden, um Datenbankereignisse oder benutzerdefinierte Nachrichten unmittelbar zu empfangen.

Technisch basiert dieses Verfahren auf WebSocket-Verbindungen, über die Supabase Änderungen an ausgewählten Tabellen oder spezifische Ereignistypen in nahezu Echtzeit an alle verbundenen Clients verteilt. 
Die Anwendung registriert sich dabei auf bestimmten Channels, die jeweils an einen fachlichen Kontext gebunden sind, beispielsweise an eine Lobby, eine Benutzer-ID oder eine Spielrunde.

Durch dieses Publish-Subscribe-Modell wird eine latenzarme und skalierbare Synchronisation zwischen mehreren Benutzern ermöglicht. 
Dies ist insbesondere für interaktive Funktionen wie Live-Einladungen, Mehrspieler-Lobbys und Chat-Kommunikation von zentraler Bedeutung, da Zustandsänderungen ohne explizite Polling-Mechanismen unmittelbar in der Benutzeroberfläche reflektiert werden.

\begin{lstlisting}
// Initialisierung einer Realtime-Subscription für die Tabelle "friend_requests"
// Zweck dieses Codes ist es, die Freundesliste und die Freundschaftsanfragen
// in der Benutzeroberfläche in Echtzeit zu synchronisieren. Dadurch werden
// Änderungen wie das Hinzufügen, Annehmen oder Entfernen von Freunden sofort
// sichtbar, ohne dass die Ansicht manuell neu geladen werden muss.
subscription = supabase.channel('friend-requests-realtime')
  .on(
    'postgres_changes',
    {
      // Reaktion auf alle relevanten Datenbankereignisse (INSERT, UPDATE, DELETE),
      // um jede Statusänderung einer Freundschaftsanfrage zu erfassen
      event: '*',

      // Angabe des Datenbankschemas, in dem die Beziehungstabelle liegt
      schema: 'public',

      // Ziel-Tabelle, die Freundschaftsanfragen und Beziehungsstatus speichert
      table: 'friend_requests'
    },
    // Callback-Funktion, die bei jeder erkannten Änderung ausgeführt wird
    () => {
      // Neuladen der Freundesliste, um neu hinzugefügte oder entfernte Freunde
      // unmittelbar in der Benutzeroberfläche darzustellen
      fetchFriends(user.id);

      // Aktualisierung aller offenen und eingehenden Freundschaftsanfragen,
      // sodass angenommene oder abgelehnte Anfragen sofort korrekt angezeigt werden
      fetchRequests(user.id);

      // Synchronisation aller bestehenden Beziehungen, um den globalen
      // Beziehungszustand (accepted, pending, declined) konsistent zu halten
      fetchAllRelations(user.id);
    }
  )
  // Aktivierung des Realtime-Kanals und Start des kontinuierlichen Empfangs
  // von Datenbankereignissen für die Live-Aktualisierung der Benutzeransicht
  .subscribe();
\end{lstlisting}

\subsubsection{Authentifizierung der Benutzer (Supabase Auth, OAuth2)}
Die Authentifizierung erfolgt über Supabase Auth als zentrales Identitäts- und Sitzungsmanagement. 
Supabase übernimmt dabei insbesondere die Verwaltung von Benutzer-Sessions, die Erstellung und Validierung von JSON Web Tokens (JWT), das Handling von Refresh-Tokens sowie sicherheitsrelevante Funktionen wie Passwort-Hashing (bei E-Mail/Passwort-Login) und die Integration externer OAuth-Provider.

\paragraph{Laden von Benutzer- und Profildaten: }
Nach erfolgreicher Authentifizierung wird die eindeutige \texttt{user.id} aus der Supabase-Session extrahiert und als primärer Schlüssel für benutzerspezifische Abfragen verwendet. 
Darauf basierend werden Profildaten (z.\,B. Benutzername, Avatar) aus einer \texttt{profiles}-Tabelle geladen und im lokalen Zustand der Anwendung gehalten, um personalisierte Inhalte und Spielzustände konsistent darstellen zu können.

\paragraph{Logout: }
Der Logout erfolgt über \texttt{supabase.auth.signOut()}, wodurch die Session invalidiert und gespeicherte Tokens entfernt werden. 
Zusätzlich wird der lokale Session-Speicher geleert und der Benutzer in den Login-Bereich der Anwendung zurückgeführt, um einen konsistenten und sicheren Zustand sicherzustellen.

\paragraph{Sicherheitsaspekte: }
Die Übertragung der Tokens erfolgt verschlüsselt über TLS. 
Google übernimmt im OAuth2-Flow die Identitätsprüfung des Benutzers; Supabase prüft anschließend die Gültigkeit und Signatur der Tokens bei jeder autorisierten Anfrage. 
Darüber hinaus schützt Row Level Security (RLS) auf Datenbankebene benutzerspezifische Datensätze vor unautorisierten Zugriffen, indem Abfragen und Mutationen nur innerhalb der durch Policies definierten Rechte möglich sind. 
Im OAuth-basierten Verfahren werden keine Passwörter in der Anwendung gespeichert oder verarbeitet.

\subsection{Spielmechanik und Logik}
Dieser Abschnitt beschreibt die grundlegende Spielmechanik von \textit{WoSamma}.
Dabei wird erläutert, wie Spielrunden erstellt werden, wie Mehrspieler-Partien
mit Freunden umgesetzt sind und nach welchen Kriterien die Punktevergabe erfolgt.

\subsubsection{Generierung der Spielrunden}

Die Generierung der Spielrunden im Einzelspieler-Modus \emph{„Ganz Österreich“} basiert auf der zufälligen Auswahl einer geografischen Position innerhalb der Landesgrenzen Österreichs. 
Hierzu wird die Staatsgrenze als Polygon modelliert, das durch eine sequenzielle Liste von Breiten- und Längengraden beschrieben wird:
\begin{lstlisting}
const austriaPolygon = [
  [47.441885, 13.070504],
  [47.657838, 13.179834],
  [47.755772, 13.020078],
  [47.882686, 13.070962],
  [48.096828, 12.838373],
  ...
  [47.447035, 12.895931],
  [47.442109, 13.077460],
  [47.491624, 13.099476]
];
\end{lstlisting}
Dieses Polygon definiert den zulässigen Suchraum für die Erzeugung gültiger Zielkoordinaten.

\paragraph{Punkt-in-Polygon-Prüfung: }
Zur Überprüfung, ob eine zufällig generierte Koordinate innerhalb des definierten Polygons liegt, wird der Ray-Casting-Algorithmus eingesetzt. 
Dabei wird von der zu prüfenden Position aus ein horizontaler Strahl konstruiert und die Anzahl der Schnittpunkte dieses Strahls mit den Polygonkanten bestimmt. 
Ist die Anzahl der Schnittpunkte ungerade, befindet sich der Punkt innerhalb des Polygons; ist sie gerade, liegt der Punkt außerhalb. 
Diese Methode gewährleistet eine effiziente und robuste Klassifikation der Koordinaten in Bezug auf die Landesgrenzen.

\paragraph{Zufällige Koordinatenerzeugung: }
Die Generierung einer Spielrunde erfolgt durch wiederholte Erzeugung zufälliger Koordinaten innerhalb eines umschließenden Rechtecks (Bounding Box), das die maximalen und minimalen Breiten- und Längengrade Österreichs abdeckt. 
Für jede generierte Position wird anschließend mittels der Punkt-in-Polygon-Prüfung verifiziert, ob sich diese innerhalb der tatsächlichen Landesgrenze befindet. 
Nur gültige Koordinaten werden als Zielposition für eine Spielrunde akzeptiert.

\paragraph{Abbruchbedingung und Robustheit: }
Um eine potenziell unendliche Schleife bei ungünstigen Zufallskonstellationen zu vermeiden, ist eine maximale Anzahl von Iterationen definiert. 
Wird diese Grenze überschritten, wird die Generierung abgebrochen und der zuletzt berechnete Wert zurückgegeben. 
Diese Maßnahme stellt die Stabilität der Anwendung sicher und verhindert eine Blockierung des Spielablaufs.

\subsubsection{Generierung des täglichen Spiels}

Das tägliche Spiel wird bei jedem Start der Anwendung initial geprüft und gegebenenfalls neu erzeugt. 
Hierzu wird zunächst eine Abfrage an das Backend durchgeführt, um festzustellen, ob für das aktuelle Kalenderdatum bereits eine gültige Spielrunde in der Datenbank existiert. 
Diese Prüfung erfolgt anhand eines datumsbasierten Identifikators, der sicherstellt, dass pro Tag genau eine eindeutige Zielposition verwendet wird.

Ist kein Eintrag für den aktuellen Tag vorhanden, wird die Zielkoordinate nach demselben Verfahren generiert wie im Einzelspieler-Modus. 
Dabei wird eine zufällige Position innerhalb der definierten Landesgrenzen Österreichs erzeugt und mittels Punkt-in-Polygon-Prüfung validiert. 
Die validierte Koordinate wird anschließend zusammen mit Metadaten (z.\,B. Erstellungsdatum, Runden-ID und Spieltyp) persistent in der Datenbank gespeichert.

Existiert bereits ein tägliches Spiel für den aktuellen Tag, wird die gespeicherte Zielposition aus der Datenbank geladen und für alle Spieler identisch verwendet. 
Durch dieses Vorgehen wird gewährleistet, dass alle Teilnehmer eines Tages unter denselben Bedingungen spielen und die Vergleichbarkeit der Ergebnisse sowie die Integrität der Ranglisten sichergestellt sind.

\subsubsection{Live-Einladungen für Freundesrunden}

Der folgende Code implementiert eine globale Echtzeit-Subscription für Lobby-Einladungen. 
Sobald eine neue Einladung für den eingeloggten Benutzer in der Datenbank erstellt wird, 
erscheint automatisch ein Popup mit den relevanten Lobby- und Einladungsinformationen.
\begin{lstlisting}
useEffect(() => {
  // Vorbedingung:
  // Abbruch der Ausführung, falls keine Benutzer-ID vorhanden ist,
  // da in diesem Fall keine personalisierten Einladungen verarbeitet werden können.
  if (!userId) return;

  // Ressourcenverwaltung:
  // Referenz auf das Realtime-Subscription-Objekt zur späteren Deregistrierung.
  let subscription: any;

  // Initialisierung:
  // Startet die Echtzeit-Überwachung für neue Lobby-Einladungen.
  async function subscribeInvites() {
    // Kanalaufbau:
    // Erstellung eines Supabase-Realtime-Kanals, der auf neue Einträge
    // in der Tabelle "lobby_invites" für den aktuellen Benutzer reagiert.
    subscription = (supabase.channel('global-lobby-invites-' + userId) as any)
      .on(
        'postgres_changes',
        {
          // Ereignistyp:
          // Reaktion ausschließlich auf das Einfügen neuer Datensätze.
          event: 'insert',

          // Schema:
          // Angabe des relevanten Datenbankschemas.
          schema: 'public',

          // Ziel:
          // Tabelle, die die Einladungen zu Mehrspieler-Lobbys enthält.
          table: 'lobby_invites',

          // Filter:
          // Einschränkung auf Einladungen, die an den aktuell angemeldeten Benutzer gerichtet sind.
          filter: `invited_user_id=eq.${userId}`
        },
        // Callback:
        // Wird ausgeführt, sobald eine neue Einladung empfangen wird.
        async (payload: any) => {
          // Datenextraktion:
          // Auslesen des neu eingefügten Einladungseintrags aus dem Ereignisobjekt.
          const invite = payload.new;

          // Datenabfrage:
          // Parallelisierte Abfrage der zugehörigen Lobby-Informationen
          // sowie des Benutzernamens des einladenden Spielers.
          const [{ data: lobby }, { data: inviter }] = await Promise.all([
            supabase.from('lobbies')
              .select('name, code')
              .eq('id', invite.lobby_id)
              .single(),
            supabase.from('profiles')
              .select('username')
              .eq('id', invite.invited_by)
              .single(),
          ]);

          // UI-Aktualisierung:
          // Setzt den lokalen Zustand zur Anzeige des Einladungs-Popups
          // mit allen relevanten Informationen für den Benutzer.
          setInvitePopup({
            id: invite.id,
            lobbyId: invite.lobby_id,
            lobbyName: lobby?.name || 'Lobby',
            lobbyCode: lobby?.code || '',
            inviterName: inviter?.username || 'Ein Freund',
          });

          // Visualisierung:
          // Einblendung des Popups mittels Animation zur Verbesserung der Benutzererfahrung.
          Animated.timing(popupAnim, {
            toValue: 0,
            duration: 350,
            useNativeDriver: true
          }).start();
        }
      )
      // Aktivierung:
      // Startet den Realtime-Kanal und beginnt mit dem Empfang von Ereignissen.
      .subscribe();
  }

  // Initialaufruf:
  // Start der Echtzeit-Überwachung nach dem Initialisieren der Komponente.
  subscribeInvites();

  // Aufräumroutine:
  // Wird beim Verlassen der Komponente ausgeführt, um die
  // Realtime-Verbindung ordnungsgemäß zu schließen und Ressourcen freizugeben.
  return () => {
    if (subscription) supabase.removeChannel(subscription);
  };
}, [userId]);
\end{lstlisting}
\subsubsection{Punkteberechnung}

In diesem Abschnitt wird die Berechnung der Punktzahl im Einzelspieler-Modus von \textit{WoSamma} detailliert beschrieben. 
Die Punktevergabe basiert auf der Entfernung in Kilometern zwischen der vom Spieler gewählten Position und dem tatsächlichen Standort.

\paragraph{Grundprinzip: }
Die erreichte Punktzahl ist eine monotone, stückweise linear fallende Funktion der Distanz $d$ (in Kilometern) zwischen der vom Spieler gewählten Position und dem tatsächlichen Zielort. 
Mit abnehmender Distanz erhöht sich die Punktzahl entsprechend. 
Negative Punktwerte sind grundsätzlich ausgeschlossen; im speziellen Einzelspieler-Modus \emph{„Ganz Österreich“} wird jedoch bei einer Distanz von mehr als $500\,\text{km}$ eine negative Punktzahl von bis zu $-5000$ Punkten vergeben. 
Diese Maßnahme dient dazu, gezielte Fehlplatzierungen zu verhindern und eine künstliche Erhöhung der Platzierung in der Bestenliste durch zufällige oder absichtlich falsche Eingaben zu unterbinden.

\paragraph{Punktebereiche und Berechnungsformeln: }

\begin{itemize}
  \item \textbf{Perfekter Treffer ($d < 1\,\text{km}$)}\\
  Maximale Punktzahl von \textbf{5000 Punkten}.\\
  \emph{Begründung:} Der Spieler befindet sich nahezu exakt auf der korrekten Position.

  \item \textbf{Sehr nah ($1\,\text{km} \leq d < 10\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 5000 auf 4000 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 5000 - 1000 \cdot \frac{d}{10}
  \]
  \emph{Beispiel:} Bei $d = 5\,\text{km}$ ergibt sich $P(5) = 4500$ Punkte.

  \item \textbf{Nah ($10\,\text{km} \leq d < 100\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 4000 auf 1000 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 4000 - 3000 \cdot \frac{d - 10}{90}
  \]
  \emph{Beispiel:} Bei $d = 55\,\text{km}$ ergibt sich $P(55) = 2500$ Punkte.

  \item \textbf{Weit entfernt ($100\,\text{km} \leq d < 500\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 1000 auf 0 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 1000 - 1000 \cdot \frac{d - 100}{400}
  \]
  \emph{Beispiel:} Bei $d = 300\,\text{km}$ ergibt sich $P(300) = 500$ Punkte.

  \item \textbf{Sehr weit entfernt ($d \geq 500\,\text{km}$)}\\
  Es werden \textbf{0 Punkte} vergeben.\\
  \emph{Begründung:} Der Tipp liegt außerhalb des definierten Bewertungsbereichs.
\end{itemize}

\begin{lstlisting}
// Distanzberechnung unter Berücksichtigung der Erdkrümmung
// Implementierung der Haversine-Formel zur Bestimmung der Großkreisentfernung
// zwischen zwei geografischen Koordinaten (Breiten- und Längengrad).
// Die berechnete Distanz dient als Grundlage für die anschließende Punkteberechnung.
function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number) {

  // Umrechnung von Gradmaß in Bogenmaß, da trigonometrische Funktionen
  // in JavaScript/TypeScript mit Radiantwerten arbeiten
  const toRad = (deg: number) => (deg * Math.PI) / 180;

  // Mittlerer Erdradius in Kilometern gemäß internationalem Referenzwert
  const R = 6371;

  // Berechnung der Differenzen der Breiten- und Längengrade in Radiant
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);

  // Haversine-Term:
  // Kombination aus Sinus- und Kosinusfunktionen zur Modellierung
  // der sphärischen Geometrie der Erdoberfläche
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);

  // Zentrale Winkelentfernung zwischen den beiden Punkten auf der Erdoberfläche
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  // Berechnung der realen Distanz in Kilometern als Produkt aus
  // Erdradius und zentralem Winkel
  const distance = R * c;

  // Rückgabe der berechneten Distanz, welche anschließend als Eingangsgröße
  // für die Punktefunktion verwendet wird
  return distance;
}
\end{lstlisting}

\subsection{Benutzerprofil}
Dieser Abschnitt beschreibt die Umsetzung des Benutzerprofils innerhalb der Anwendung.
Das Benutzerprofil dient zur Darstellung spielrelevanter Informationen sowie zur Verwaltung
von freigeschalteten Inhalten und individuellen Einstellungen.

\subsubsection{Profilanpassung}
Beim Öffnen des Benutzerprofils werden die gespeicherten Basisdaten des angemeldeten Nutzers aus der Datenbank geladen und im lokalen Zustand der Anwendung initialisiert. 
Hierzu zählen insbesondere der Benutzername, die zugewiesene Rolle sowie individuelle Profileinstellungen. 
Zusätzlich wird ermittelt, welches Profilbild aktuell als aktiv markiert ist und welche Profilbilder dem Benutzer grundsätzlich zur Verfügung stehen beziehungsweise bereits freigeschaltet wurden.

Die Auswahl eines neuen Profilbilds erfolgt über einen konsistenten Aktualisierungsmechanismus. 
Zunächst werden alle bisher als aktiv markierten Profilbilder des Benutzers zurückgesetzt. 
Anschließend wird das neu gewählte Profilbild eindeutig als aktiv gesetzt und persistent in der Datenbank gespeichert. 
Dieses Verfahren stellt sicher, dass zu jedem Zeitpunkt genau ein Profilbild als gültig ausgewählt ist.

Benutzer mit administrativen oder entwicklungsbezogenen Rollen erhalten automatisch Zugriff auf alle verfügbaren Profilbilder. 
Diese Berechtigung wird serverseitig über rollenbasierte Zugriffsregeln realisiert und clientseitig entsprechend visualisiert.

Werden Profildaten geändert, so erfolgt eine zentrale Speicherung der aktualisierten Attribute in der Datenbank. 
Hierzu zählen unter anderem der Benutzername, das Geburtsdatum sowie – sofern vom Authentifizierungssystem unterstützt – E-Mail-Adresse und Zugangsdaten. 
Durch die zentrale Persistenz wird gewährleistet, dass die Änderungen konsistent in allen Ansichten der Anwendung reflektiert werden.

\subsubsection{Kaufen und Freischalten von Profilinhalten}
Der integrierte Shop stellt dem Benutzer alle verfügbaren Profilinhalte, insbesondere Profilbilder und Zubehör, in einer strukturierten Übersicht dar. 
Bereits freigeschaltete Inhalte werden visuell von noch nicht erworbenen Elementen unterschieden, um den aktuellen Besitzstatus transparent darzustellen.

Der Erwerb eines Profilinhalts erfolgt über einen simulierten Kaufprozess ohne Anbindung an ein externes Bezahlsystem. 
Bei Bestätigung des Kaufs wird das ausgewählte Element dem Benutzer dauerhaft in der Datenbank zugeordnet. 
Diese Zuordnung wird in einer Besitzrelation gespeichert, die den Benutzer eindeutig mit den freigeschalteten Inhalten verknüpft.

Nach erfolgreichem Erwerb werden die freigeschalteten Inhalte unmittelbar im Profilbereich verfügbar gemacht und können dort als aktive Darstellungselemente ausgewählt werden. 
Ein vergleichbarer Mechanismus wird für Zubehör verwendet, wobei der Besitzstatus ebenfalls persistent gespeichert und in der Benutzeroberfläche entsprechend visualisiert wird.

Im öffentlichen Profil eines Benutzers wird stets das aktuell aktivierte Profilbild angezeigt. 
Diese Darstellung basiert auf der zuletzt im privaten Profil vorgenommenen Auswahl und gewährleistet eine konsistente Repräsentation des Benutzers innerhalb der Anwendung.


\subsection{Freundesystem}
Das Freundesystem ermöglicht die soziale Interaktion zwischen den Benutzern der Anwendung.
Es dient dazu, Spieler miteinander zu vernetzen, gemeinsame Spielrunden zu starten
und den Austausch innerhalb der Anwendung zu fördern.
\subsubsection{Freundschaftsanfragen}
Die Anwendung stellt eine Suchfunktion zur Verfügung, über die Benutzer gezielt nach anderen Spielern suchen und Freundschaftsanfragen initiieren können. 
Beim Senden einer Anfrage wird in der Datenbank eine neue Beziehung zwischen den beiden Benutzern angelegt und initial mit dem Status \texttt{pending} versehen.

Vor dem Erstellen einer Anfrage erfolgt eine serverseitige Validierung, um sicherzustellen, dass zwischen den beiden Benutzern noch keine bestehende Beziehung vorliegt und dass der Empfänger den Erhalt von Freundschaftsanfragen nicht deaktiviert hat. 
Diese Prüfungen verhindern redundante Einträge und unerwünschte Kontaktaufnahmen.

Eingehende Anfragen werden dem Benutzer in einer konsolidierten Übersicht angezeigt. 
Der Benutzer kann jede Anfrage entweder annehmen oder ablehnen, wodurch der Status der Beziehung entsprechend auf \texttt{accepted} beziehungsweise \texttt{declined} gesetzt wird. 
Die Listen der bestehenden Freundschaften und offenen Anfragen werden über eine Echtzeit-Synchronisation automatisch aktualisiert, sodass Statusänderungen unmittelbar in der Benutzeroberfläche reflektiert werden.

\subsubsection{Herausfordern von Freunden}
Ausgehend von der Freundesliste kann ein Benutzer einen direkten Mehrspieler-Vergleich initiieren. 
Hierzu wird eine private Lobby erzeugt, in der der initiierende Benutzer als Host eingetragen wird. 
Der ausgewählte Freund wird über einen Einladungsmechanismus mit dieser Lobby verknüpft.

Zusätzlich wird eine Beitrittsoption bereitgestellt, sofern sich der Freund in einer offenen, öffentlichen Lobby befindet und dort freie Teilnehmerplätze verfügbar sind. 
Einladungen werden als eigenständige Datensätze in der Datenbank geführt und können vom Empfänger explizit angenommen oder abgelehnt werden. 
Dieses Verfahren stellt sicher, dass der Beitritt zu einer Spielrunde stets kontrolliert und nachvollziehbar erfolgt.

\subsubsection{Chatfunktion}
Die Chatfunktion ist als bidirektionale 1-zu-1-Kommunikation zwischen zwei befreundeten Benutzern realisiert. 
Nachrichten werden in einer dedizierten Nachrichtentabelle persistent gespeichert und über Echtzeit-Mechanismen an beide Teilnehmer synchronisiert.

Beim Öffnen eines Chatfensters werden alle vorhandenen Nachrichten beider Benutzer aus der Datenbank geladen. 
Neu eingehende Nachrichten werden unmittelbar in der Benutzeroberfläche angezeigt, wodurch eine kontinuierliche und nahezu verzögerungsfreie Kommunikation ermöglicht wird.

\subsubsection{Anzeigen von Benutzerprofilen}
Benutzerprofile können sowohl aus der Freundesliste als auch aus spielbezogenen Kontexten, wie beispielsweise Lobbys oder Bestenlisten, aufgerufen werden. 
Das öffentliche Profil stellt grundlegende Informationen wie den Benutzernamen, die zugewiesene Rolle sowie ausgewählte statistische Kennzahlen dar.

Darüber hinaus wird das aktuell aktive Profilbild des Benutzers angezeigt. 
Diese Darstellung basiert auf der zuletzt im privaten Profil vorgenommenen Auswahl und gewährleistet eine konsistente Repräsentation des Benutzers über alle Ansichten der Anwendung hinweg.

\subsection{Integration der Google APIs}
In diesem Abschnitt wird die technische Einbindung der externen Google-Dienste beschrieben, die zur Darstellung, Interaktion und Auswertung geografischer Inhalte innerhalb der Anwendung verwendet werden. 
Die Google Maps API und die Google Street View API bilden die visuelle und funktionale Grundlage für die Spielmechanik, indem sie sowohl die kartografische Interaktion als auch die realitätsnahe Darstellung der Spielorte ermöglichen. 
Der Fokus liegt auf der Architektur der Einbindung, der Kommunikation zwischen WebView und nativer Anwendung sowie auf der Validierung und Synchronisation der bereitgestellten Geodaten.

\subsubsection{Verwendung der Google Maps API}
Die Anwendung integriert die Google Maps API zur Darstellung und Interaktion mit geografischen Karteninhalten. 
Der zugehörige API-Schlüssel wird zur Laufzeit aus einer zentralen Konfigurationstabelle im Backend geladen und im Arbeitsspeicher der Anwendung zwischengespeichert. 
Durch dieses Caching wird vermieden, dass der Schlüssel bei jedem Wechsel der Benutzeransicht erneut aus der Datenbank abgerufen werden muss, wodurch sowohl die Netzwerklast als auch die Latenz reduziert werden.

Die Karten werden nicht als native Kartenkomponenten gerendert, sondern als Web-Inhalte in einer \textit{WebView}. 
Hierzu wird dynamisch eine HTML-Seite erzeugt, in die das Google Maps JavaScript SDK eingebunden wird. 
Diese Seite wird innerhalb der mobilen Anwendung ausgeführt und ermöglicht eine plattformunabhängige Nutzung identischer Kartenlogik auf iOS und Android.

Für die Umsetzung der Spielmechanik werden unterschiedliche Kartenvarianten erzeugt, die jeweils auf spezifische Interaktionsszenarien ausgelegt sind. 
Hierzu zählen insbesondere sogenannte \emph{Guess-Karten}, welche das Setzen eines Markers zur Abgabe eines Spieler-Tipps ermöglichen, sowie \emph{Ergebnis-Karten}, die die gewählte Position und den tatsächlichen Zielstandort simultan visualisieren.

Benutzerinteraktionen innerhalb der WebView, wie das Platzieren eines Markers, das Verändern des Zoom- und Kartenfokus oder das Auslösen von Ereignissen, werden über einen Nachrichtenkanal an die native Anwendung zurückgemeldet. 
Diese bidirektionale Kommunikation stellt sicher, dass die Benutzeroberfläche und die zugrunde liegende Spiel- und Auswertungslogik stets synchron zum aktuellen Kartenzustand bleiben.

\subsubsection{Einbindung der Street-View-Bilder}
Die Einbindung der Street-View-Funktionalität erfolgt ebenfalls über das Google Maps JavaScript SDK innerhalb einer WebView. 
Hierbei wird ein Street-View-Panorama erzeugt, das dem Benutzer eine 360-Grad-Ansicht des jeweiligen Spielorts bereitstellt und die visuelle Grundlage für das spielerische Erkundungskonzept bildet.

Zur Reduktion visueller Komplexität werden zentrale Benutzeroberflächenelemente des Street-View-Panoramas, wie beispielsweise Navigations- und Zoom-Steuerelemente, weitgehend ausgeblendet. 
Dadurch wird der Fokus des Benutzers auf die Umgebung und die räumliche Orientierung innerhalb der Spielansicht gelenkt.

Vor der Initialisierung eines Panoramas wird geprüft, ob für die gewünschte Region ein gültiger Street-View-Datenpunkt verfügbar ist. 
Diese Prüfung erfolgt über eine Kombination aus Street-View-Suchanfragen und, falls erforderlich, zusätzlichen Validierungsmechanismen wie regionsbasierten oder polygonalen Verfügbarkeitsprüfungen. 
Wird kein geeigneter Punkt gefunden, wird entweder eine alternative Position gesucht oder dem Benutzer eine entsprechende Fehlermeldung angezeigt.

Die aktuelle Kameraausrichtung des Panoramas (Heading) wird in regelmäßigen Abständen aus der WebView an die native Anwendung übertragen. 
Diese Information wird verwendet, um zusätzliche Overlays, wie beispielsweise einen Kompass, synchron zur Blickrichtung des Benutzers darzustellen und somit eine konsistente und kohärente Benutzererfahrung zu gewährleisten.

