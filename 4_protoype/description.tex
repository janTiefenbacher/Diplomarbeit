In diesem Kapitel wird die technische Umsetzung des Spiels \textit{WoSamma} dokumentiert.
Dabei werden die verwendete Systemumgebung, eingesetzte Technologien sowie die grundlegenden
Konzepte der Implementierung beschrieben, um einen strukturierten Überblick über die Realisierung
der Anwendung zu geben.

\section{Systemumgebung}
Das Spiel WoSamma ist eine mobile Anwendung für iOS und Android und wurde mit React Native und TypeScript entwickelt.
Die Entwicklung erfolgte unter Windows mithilfe von Visual Studio Code.
Für das Veröffentlichen der Anwendung auf iOS-Geräten sowie für abschließende Tests und Fehlerbehebungen wurde Xcode unter macOS in Verbindung mit einem Apple-Developer-Konto verwendet.
Die Tests für Android wurden mit Android Studio auf Emulatoren durchgeführt.
Die Anwendung ist für eine zukünftige Veröffentlichung im Apple App Store sowie im Google Play Store vorgesehen.

\subsection{Verwendete Technologien}
\begin{itemize}
    \item \textbf{React Native} – Framework zur Entwicklung plattformübergreifender mobiler Anwendungen für iOS und Android.
    \item \textbf{TypeScript} – Typsichere Erweiterung von JavaScript, die bewusst anstelle von JavaScript gewählt wurde, um die Wartbarkeit, Lesbarkeit und Codequalität der Anwendung zu erhöhen.
    \item \textbf{Supabase (PostgreSQL)} – Backend-as-a-Service, das zentrale Funktionen wie Authentifizierung, Echtzeitdaten, Datenbankverwaltung sowie eine REST-API bereitstellt und damit den Entwicklungsaufwand deutlich reduziert.
    \item \textbf{Google Maps API} – API zur Verarbeitung und Darstellung geografischer Daten sowie zur Positionsbestimmung innerhalb des Spiels.
    \item \textbf{Google Street View API} – API zur Integration von 360-Grad-Street-View-Bildern aus ganz Österreich, welche die Grundlage für das GeoGuessr-ähnliche Spielkonzept bildet.
    \item \textbf{GitHub} – Plattform zur Versionsverwaltung, die eine strukturierte Zusammenarbeit im Team sowie die kontinuierliche Aktualität des Quellcodes sicherstellt.
    \item \textbf{Jira} – Tool zur Projektplanung und Aufgabenverwaltung, das im Rahmen einer agilen Vorgehensweise für die Diplomarbeit eingesetzt wurde.
    \item \textbf{Figma} – Design- und Prototyping-Tool zur Erstellung von Mockups und interaktiven Prototypen, welche als visuelle Grundlage für die Benutzeroberfläche dienten.
\end{itemize}

\section{Implementierung}
Dieses Kapitel beschreibt die technische Umsetzung des Spiels \textit{WoSamma}. 
Dabei wird auf den Aufbau der Anwendungsarchitektur, die Implementierung des Frontends, 
die Anbindung des Backends sowie auf die zentrale Spiellogik eingegangen. 
Der Fokus liegt auf den verwendeten Konzepten, der Struktur des Quellcodes 
und den getroffenen technischen Entscheidungen.

\subsection{Architektur der Anwendung}
Die Anwendung \textit{WoSamma} folgt einer klaren Trennung zwischen Frontend, Backend 
und externen Diensten. 
Das Frontend wurde mit React Native umgesetzt und ist für die Benutzeroberfläche, 
die Spiellogik sowie die Interaktion mit dem Benutzer verantwortlich.
Das Backend basiert auf Supabase und übernimmt Aufgaben wie Authentifizierung, 
Datenpersistenz und Echtzeitkommunikation.
Externe APIs, wie die Google Maps und Google Street View API, werden zur Bereitstellung 
von geografischen Daten und 360-Grad-Bildern verwendet.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{content/img/4_Technische_Umsetzung/System_Architektur.jpg}
    \caption{Systemarchitektur der Anwendung WoSamma}
    \label{fig:beispielabbildung}
\end{figure}

\subsection{Frontend-Implementierung \& Plannung}
Die Planung und die dementsprechende Umsetzung des Frontends stellen einen wesentlichen Teil der Implementierung dar. Dieser Bereich ist sehr umfangreich und hatte eine hohe Priorität, da er die Kommunikation zwischen Benutzer und Applikation abbildet. Aufbauend auf den zuvor beschriebenen theoretischen Grundlagen zu User Experience, Informationsarchitektur und Interface-Design wurden zunächst die funktionalen Anforderungen an das Frontend definiert. Ziel war es, eine übersichtliche, intuitive und visuell konsistente Benutzeroberfläche zu schaffen, die sowohl im Einzel- als auch im Mehrspielerbetrieb eine einfache und verständliche Nutzung ermöglicht.

Als Grundlage der Planung dienten die Erstellung von Wireframes und einem Prototypen sowie die Ausarbeitung der Informationsarchitektur. Die eigentliche Implementierung orientiert sich an den meisten Stellen stark an dem zuvor erstellten Prototyp, da dieser bereits eine sehr genaue Vorstellung der finalen Benutzeroberfläche vermittelte.
\subsubsection{Informationsarchitektur, Wireframes \& Prototypen}

Die entwickelte Informationsarchitektur orientiert sich an den zuvor beschriebenen theoretischen Grundlagen der Informationsarchitektur und setzt diese konsequent in eine klar strukturierte Navigationshierarchie um. Ausgehend von einem zentralen Einstiegspunkt (Home), welcher nach Login erreicht wird, werden die Inhalte logisch in thematisch zusammengehörige Bereiche wie Einzelspieler, Mehrspieler und Bestenliste gegliedert. Dabei wurde auf eine begrenzte Auswahl pro Navigationsebene sowie auf eine eindeutige Benennung der Menüpunkte geachtet, um die kognitive Belastung der Nutzer gering zu halten. Durch die klare Trennung von Kernfunktionen (z. B. Spielmodi) und unterstützenden Funktionen (z. B. Profil, Shop, Neuigkeiten) wird eine gute Orientierung gewährleistet. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{content/img/4_Technische_Umsetzung/IA.jpg}
    \caption{Informationsarchitektur der Anwendung WoSamma}
    \label{fig:beispielabbildung}
\end{figure}

Das erstellte Wireframe diente als strukturelle Grundlage der Anwendung. Der Fokus lag auf der Anordnung der Inhalte, der grundsätzlichen Struktur der einzelnen Bereiche und der Führung der Nutzer durch das System. Visuelle Gestaltungselemente wie Farbkonzepte, Typografie oder detaillierte UI-Komponenten sind bewusst offen gelassen worden, um den Schwerpunkt auf Struktur, Hierarchie und Nutzerführung zu legen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{content/img/4_Technische_Umsetzung/Wireframes.jpg}
    \caption{Wireframes der Anwendung WoSamma}
    \label{fig:beispielabbildung}
\end{figure}

Die im vorherigen Kapitel beschriebenen Designkonzepte und Gestaltungsprinzipien wurden im Prototyp gezielt und konsequent umgesetzt. Aufbauend auf den theoretischen Grundlagen zu modernem App-Design, Dark-Mode-Konzepten, Barrierefreiheit und klarer Informationshierarchie wurde der Prototyp als High-Fidelity-Referenz entwickelt. Die visuelle Gestaltung orientiert sich an einem durchgängigen Dark-Mode-Design mit bewusst gewählten Kontrasten, um eine gute Lesbarkeit unter unterschiedlichen Lichtbedingungen sicherzustellen.

Aspekte der Barrierefreiheit wurden im Prototyp unter anderem durch ausreichend große Touch-Ziele, klare Beschriftungen, eindeutige Icons sowie eine logisch aufgebaute Navigations- und Fokusstruktur berücksichtigt. Die hierarchische Anordnung von Inhalten, wie in den Abschnitten zu Informationsarchitektur und Struktur beschrieben, spiegelt sich direkt in der Seitenaufteilung und Navigation des Prototyps wider. Farben, Typografie und Abstände wurden so eingesetzt, dass visuelle Orientierung unterstützt und eine intuitive Nutzung ermöglicht wird.

Der Prototyp dient damit nicht nur als visuelle Vorschau, sondern als konkrete Umsetzung der zuvor definierten UI/UX- und Designprinzipien und bildet die Grundlage für die technische Realisierung der Anwendung.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{content/img/4_Technische_Umsetzung/Prototyp_SH.jpg}
    \caption{Prototyp der Anwendung WoSamma(Überblick)}
    \label{fig:beispielabbildung}
\end{figure}


\subsubsection{Responsives Design }
Das Responsive Design der Anwendung wurde durch den gezielten Einsatz flexibler Layout- und Größenkonzepte umgesetzt. Mithilfe von Flexbox (flex: 1) passen sich Container automatisch an den verfügbaren Bildschirmraum an, während prozentuale Breiten wie width: '95\%' oder dynamische Werte auf Basis der Bildschirmbreite (windowWidth * 0.95) eine adaptive Skalierung auf unterschiedlichen Geräten ermöglichen. Zusätzlich sorgen Einschränkungen wie maxWidth, minHeight und maxHeight dafür, dass UI-Elemente auf großen wie kleinen Displays gut nutzbar bleiben. Ergänzend wurden feste Seitenverhältnisse (aspectRatio) für visuelle Konsistenz sowie KeyboardAvoidingView für ein geräteabhängiges, nutzerfreundliches Verhalten bei Texteingaben eingesetzt. Dadurch bleibt die Benutzeroberfläche über verschiedene Bildschirmgrößen und Nutzungsszenarien hinweg stabil, übersichtlich und bedienbar.
Hier ein paar konkrete Beispiele:
\begin{lstlisting}
container: {
  flex: 1,
  backgroundColor: '#181d23',
  width: '100%',
},
webview: {
  flex: 1,
  width: '100%',
}
\end{lstlisting}
\begin{lstlisting}
const windowWidth = Dimensions.get('window').width;

<TouchableOpacity
  style={[styles.mainCard, { width: windowWidth * 0.95 }]}
>
  <Image source={...} resizeMode="contain" />
</TouchableOpacity>
\end{lstlisting}
\begin{lstlisting}
<LinearGradient
  style={{
    padding: 12,
    borderRadius: 16,
    maxWidth: '80%',
  }}
>
  <Text>{item.content}</Text>
</LinearGradient>
\end{lstlisting}


\subsubsection{Spielansicht und Benutzerinteraktion}
In den folgenden Abschnitten werden die wichtigsten Aspekte des UI sowie der Benutzerinteraktion beschrieben. Hierbei
wird aktiv auf Code eingegangen und erläutert, wie dieser Funktioniert und welchen Zweck er erfüllt.

\paragraph{Pin-Platzierung}
\mbox{}\\
Die Platzierung des Pins auf der Karte ist die wohl zentralste Interaktionsmöglichkeit im Spiel. Ohne diese Funktion hätte das Spiel keinen
Sinn, da der Spieler so seine Vermutung über den Standort abgibt. Diese Funktionalität wird hier rein anhand des Einzepspieler-Modus erklärt,
da sich die reine Platzierungslogik im Mehrspieler-Modus bzw. in der täglichen Challenge nicht unterscheidet.
Der folgende Codeausschnitt zeigt, wie die Pin-Platzierung technisch umgesetzt wurde:

\begin{lstlisting}
// Funktion, die ein komplettes HTML-Dokument als String zurückgibt
// Dieses HTML wird später in der View geladen
const getAustriaMapHTML = (apiKey: string) => `
<!DOCTYPE html>
<html>
  <head>
    <!-- Sorgt dafür, dass die Karte auf Mobile richtig skaliert -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
      /* Map soll den kompletten Bildschirm ausfüllen */
      html, body, #map {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #181d23;
      }
    </style>

    <!-- Google Maps JavaScript API mit dynamisch übergebenem API-Key -->
    <script src="https://maps.googleapis.com/maps/api/js?key=${apiKey}"></script>
  </head>

  <body>
    <!-- Container für die Google Map -->
    <div id="map"></div>

    <script>
      // Globale Variablen:
      // map: Referenz auf die Google Map
      // marker: Referenz auf den aktuell gesetzten Pin
      var map, marker = null;

      // Initialisiert die Google Map
      function initMap() {

        // Erstellen der Map mit Startposition Österreich
        map = new google.maps.Map(document.getElementById('map'), {
          center: { lat: 47.5162, lng: 14.5501 }, // Mittelpunkt Österreich
          zoom: 7,                              // Zoom-Level
          streetViewControl: false,             // UI-Elemente deaktiviert
          mapTypeControl: false,
          fullscreenControl: false,
          backgroundColor: '#181d23',
        });

        // Listener für Klicks auf die Karte
        map.addListener('click', function(e) {

          // Falls bereits ein Pin existiert, wird er entfernt
          // -> es gibt IMMER nur einen aktiven Guess-Pin
          if (marker) marker.setMap(null);

          // Neuer Marker wird an der Klickposition gesetzt
          marker = new google.maps.Marker({
            position: e.latLng,
            map: map
          });

          // Übergibt die Koordinaten an die React-Native-App
          // Das ist die eigentliche "Spieler gibt seinen Guess ab"-Aktion
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'pin',
              lat: e.latLng.lat(),
              lng: e.latLng.lng()
            })
          );
        });
      }

      // Startet die Map nach dem Laden
      initMap();
    </script>
  </body>
</html>
`;
\end{lstlisting} 
Dieser Code sorgt nun dafür, dass eine interaktive Google Map in der Spielansicht dargestellt wird und der Spieler seine Schätzung abgeben kann.
Wichtig hierbei sind, dass der Spieler immer nur einen einzigen Pin setzen kann, also er nur eine Schätzung abgeben kann. Weiteres ist es wichtig,
das hier gewisse UI-Elemente der Google Maps API deaktiviert werden, da diese für die Spiellogik nicht relevant sind und nur stören würden, hierzu zählen:
\begin{itemize}
    \item Street View Control/das gelbe Männchen
    \item Umschaltfunktion zwischen Kartenansicht und Satellitenansicht
    \item Vollbildmodus-Fuktion, dies ist besonders wichtig um UI-Chaos zu verhindern
\end{itemize}

\paragraph{Anzeige mehrerer Pins im Mehrspieler-Modus}
\mbox{}\\
Im gegensatz zum Einzelspieler-Modus, in dem der Spieler nur seinen eigenen Pin setzen und am Ende auch sehen kann, müssen beim Ergebnis des Mehrspieler-Modus mehrere
Pins gleichzeitig dargestellt werden. Dies ist notwendig, damit der Spieler die Vermutungen seiner Gegner sehen und mit seiniger vergleichen kann. Wie die genaue
Visualisierung der geschätzten und der korrekten Position aussieht, wird im nächsten Abschnitt beschrieben. Hier wird vorerst nur beschrieben, wie man es schafft mehrere Pins 
von unterschiedlichen Spielern auf der Karte darzustellen. 
Essenziell für die möglichkeit mehrere Pins anzuzeigen, ist folgender Ablauf:
\begin{enumerate}
    \item Spieler setzt Pin auf Karte
    \item Pin-Koordinaten werden im State gespeichert (\texttt{setPin})
    \item Bei {Tipp abgeben} $\rightarrow$ Speicherung in \texttt{user\_rounds} (Datenbank):
    \begin{itemize}
      \item \texttt{game\_id} (Lobby-ID)
      \item \texttt{user\_id} (eigene ID)
      \item \texttt{round\_number}
      \item \texttt{guess\_lat}, \texttt{guess\_lng}
      \item \texttt{finished: true}
    \end{itemize}
    \item Echtzeit-Tracking (alle 2 Sekunden):
    \begin{itemize}
      \item Prüft, wie viele Spieler bereits getippt haben
      \item Zeigt Fortschritt: \texttt{\{guessedCount\}/\{totalPlayers\}}
    \end{itemize}
    \item Result-Map lädt alle Tipps:
    \begin{itemize}
      \item Polling alle 2 Sekunden aus \texttt{user\_rounds}
      \item Lädt Usernames und Avatare
      \item Zeigt alle Pins mit unterschiedlichen Farben und deren dazugehörigen Usernamen, der Eigene wird mit höherem zIndex angezeigt für bessere Sichtbarkeit
      \item Zeigt Linien zur Lösung und Distanz-Labels (genauere Beschreibung im nächsten Abschnitt)
    \end{itemize}
\end{enumerate}
Der folgende Codeausschnitt zeigt, wie man es nun schafft all die gespeicheerten Pins aus der Datenbank auf der Karte anzuzeigen:
\begin{lstlisting}
/**
 * Erstellt den HTML-/JavaScript-Code für die Ergebnis-Karte im Mehrspieler-Modus.
 * In diesem Abschnitt liegt der Fokus ausschließlich auf der Darstellung
 * mehrerer Pins unterschiedlicher Spieler auf der Karte.
 *
 * Die ausgelesenen Tipps sind als Array namens "guesses" vorhanden, diese werden vorher aus der Datenbank gelesen und aufbereitet.
 *
 * Die Visualisierung der Verbindungslinien zwischen Tipp und korrekter Lösung
 * sowie die Distanzberechnung werden bewusst ausgelassen und im nächsten
 * Abschnitt separat erläutert.
 */
function getResultMapHTML({ solutionLat, solutionLng, guesses, apiKey, selfUserId }: any) {

  // Vordefinierte Google-Maps-Standard-Icons in unterschiedlichen Farben.
  // Die Farben rotieren, sodass mehrere Spieler gleichzeitig klar unterscheidbar sind.
  const pinIcons = [
    'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/blue-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/purple-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/orange-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/pink-dot.png',
    'http://maps.google.com/mapfiles/ms/icons/cyan-dot.png',
  ];

  //@ts-ignore
  // Für jeden gespeicherten Tipp wird JavaScript-Code erzeugt,
  // der einen eigenen Marker inklusive Username-Overlay erstellt.
  const markersJS = guesses.map((g, i) => `

    // === Marker (Pin) für einen Spieler ===
    // Jeder Marker repräsentiert einen gespeicherten Tipp aus der Datenbank
    var marker = new google.maps.Marker({
      position: { lat: ${g.lat}, lng: ${g.lng} }, // Pin-Koordinaten des Spielers
      map: map,                                  // Anzeige auf der Ergebnis-Karte

      // Farbiger Pin zur visuellen Unterscheidung der Spieler
      icon: '${pinIcons[i % pinIcons.length]}',

      // Username als Tooltip (z.B. sichtbar bei Hover am Desktop)
      title: '${g.username}',

      // Der eigene Pin wird priorisiert gerendert,
      // damit er bei Überlagerungen stets sichtbar bleibt
      zIndex: ${g.userId === selfUserId ? 10 : 1}
    });

    // === Username-Overlay über dem Pin ===
    // Der Name des Spielers wird direkt über dem Marker angezeigt,
    // um eine eindeutige Zuordnung der Tipps zu ermöglichen
    (function() {
      var nameDiv = document.createElement('div');

      // UI-Styling für gute Lesbarkeit auf der dunklen Kartenansicht
      nameDiv.style.fontSize = '13px';
      nameDiv.style.fontWeight = 'bold';
      nameDiv.style.color = '#fff';
      nameDiv.style.background = 'rgba(67,160,71,0.85)';
      nameDiv.style.padding = '2px 8px';
      nameDiv.style.borderRadius = '8px';
      nameDiv.style.textShadow = '0 0 2px #000, 0 0 1px #000';

      nameDiv.innerText = '${g.username}';

      // OverlayView ermöglicht das Platzieren von HTML-Elementen über der Map
      var nameOverlay = new google.maps.OverlayView();

      // Hinzufügen des Namens zur Overlay-Ebene der Karte
      nameOverlay.onAdd = function() {
        var panes = this.getPanes();
        panes.overlayImage.appendChild(nameDiv);
      };

      // Positionierung des Overlays relativ zum Marker
      nameOverlay.draw = function() {
        var projection = this.getProjection();
        var pos = projection.fromLatLngToDivPixel(
          new google.maps.LatLng(${g.lat}, ${g.lng})
        );
        nameDiv.style.left = pos.x + 'px';
        nameDiv.style.top = (pos.y - 28) + 'px'; // leicht oberhalb des Pins
        nameDiv.style.position = 'absolute';
        nameDiv.style.transform = 'translate(-50%, -100%)';
      };

      nameOverlay.setMap(map);
    })();

    /*
     * Hinweis:
     * Die Darstellung der Verbindungslinien zwischen den getippten Positionen
     * und der korrekten Lösung sowie die zugehörige Distanzberechnung
     * werden im nächsten Abschnitt detailliert beschrieben und sind
     * hier bewusst nicht enthalten.
     */

  `).join('\n');
}

\end{lstlisting} 

\paragraph{Visualisierung der geschätzten und korrekten Position}
\mbox{}\\
Ein weiterer essenzieller Bestandteil der Spielansicht ist die Visualisierung des Ergebnisses nach abgabe des Tipps.
Hierbei muss sowohl die korrekte Position als auch die getippte Position des Spielers dargestellt werden und mit Hilfe einer Linie die Distanz erläutert wird.
Egal welchen Modus der Spieler spielt, die Linien eigenschaften sind bis auf die Farbe immer gleich und werden in diesem Code-Block definiert:
\begin{lstlisting}
var line = new google.maps.Polyline({
  path: [ { lat: ${solutionLat}, lng: ${solutionLng} }, { lat: ${guessLat}, lng: ${guessLng} } ], //Weg der gezeichnet werden soll zwischen Guess des Spielers und der Lösung
  geodesic: true,        // Kurvenlinie entlang der Erdoberfläche
  strokeColor: '#2563eb', // Blaue Linie in allen Einzelspieler-Modi, im Mehrspieler ist diese Linie Schwarz/Dunkelgrau
  strokeOpacity: 1.0,   // Volle Deckkraft
  strokeWeight: 3,       // Linienstärke 3px
  map: map
});
\end{lstlisting}
Ein weiterer wichtiger Aspekt ist die Anzeige der tatsächlichen Distanz in Kilometern zwischen dem gesetzten Pin und der korrekten Position. Im Einzelspieler-Modus bzw. in der Täglichen Challenge wird die Distanz 
nicht direkt über der Verbindungsinie, sondern unten am Screen angezeigt:
\begin{lstlisting}
<View style={styles.resultBox}>
  {/* Textuelles Feedback für den Spieler:
      Zeigt direkt an, wie weit die Schätzung vom tatsächlichen Standort entfernt war */}
  <Text style={styles.resultText}>
    Deine Schätzung war {distance.toFixed(1)} km vom echten Standort entfernt
  </Text>

  {/* Fortschrittsbalken zur visuellen Darstellung der erreichten Punkte.
      Der Balken skaliert relativ zur maximal erreichbaren Punktzahl (5000). */}
  <View style={styles.progressBarBg}>
    <View
      style={[
        styles.progressBar,
        {
          // Begrenzung der Breite auf 0–100 %, um Layout-Probleme zu vermeiden
          width: `${Math.max(
            0,
            Math.min(100, (100 * points) / 5000)
          )}%`,
        },
      ]}
    />
  </View>

  {/* Anzeige der erreichten Punktzahl als numerischer Wert */}
  <Text style={styles.points}>
    {points} Punkte
  </Text>

  {/* Button-Leiste für weitere Aktionen nach Abschluss der Runde */}
  <View style={styles.buttonRow}>

    {/* Button zum Verlassen der aktuellen Lobby / Runde.
        Öffnet ein Bestätigungs-Modal, um unbeabsichtigtes Verlassen zu verhindern */}
    <TouchableOpacity
      style={styles.leaveBtn}
      onPress={() => setShowLeaveModal(true)}
    >
      <Text style={styles.leaveText}>Verlassen</Text>
    </TouchableOpacity>

    {/* Button zum Starten der nächsten Runde.
        Je nach Spielmodus (z.B. Bundesländer-Modus oder Österreich gesamt)
        wird der entsprechende Screen geladen */}
    <TouchableOpacity
      style={styles.nextBtn}
      onPress={() => {
        if (route.params && route.params.bundeslaender) {
          navigation.replace('StreetViewBundesland', {
            bundeslaender: route.params.bundeslaender,

            // Zufälliger Parameter erzwingt ein Neuladen der View
            // (verhindert Caching-Probleme bei erneutem Eintritt)
            _rnd: Math.random().toString(36).slice(2),
          });
        } else {
          navigation.replace('StreetViewAustria');
        }
      }}
    >
      <Text style={styles.nextText}>Nächste Runde</Text>
    </TouchableOpacity>
  </View>
</View>
\end{lstlisting}
Im Gegensatz dazu, wird im Mehrspieler-Modus die Distanz zwischen der getippten Position und der korrekten Lösung direkt auf der Verbindungslinie angezeigt. Dadurch können alle Spieler nicht nur ihre eigene, sondern auch die Abweichungen der Mitspieler nachvollziehen und miteinander vergleichen. Die Umsetzung dieser Visualisierung erfolgt mithilfe des folgenden Codeausschnitts:
\begin{lstlisting}
// === Distanz-Berechnung + Anzeige als Label auf der Verbindungslinie ===
// Dieser Block berechnet die Entfernung zwischen Tipp (g.lat/g.lng) und Lösung (solutionLat/solutionLng)
// und blendet den Wert als Text ("xx.xx km") mittig auf der Linie ein.
(function() {
  // Erdradius in Kilometern (für die Haversine-Formel)
  var R = 6371;

  // Umrechnung der Breiten-/Längendifferenz in Bogenmaß (Radians)
  var dLat = (${solutionLat} - ${g.lat}) * Math.PI / 180;
  var dLng = (${solutionLng} - ${g.lng}) * Math.PI / 180;

  // Haversine-Formel: Berechnung der Großkreisdistanz auf einer Kugel
  var a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(${g.lat} * Math.PI / 180) *
    Math.cos(${solutionLat} * Math.PI / 180) *
    Math.sin(dLng/2) * Math.sin(dLng/2);

  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  var dist = R * c; // Distanz in km

  // Mittelpunkt zwischen Tipp und Lösung:
  // Dort wird das Distanzlabel platziert (damit es "auf der Linie" sitzt)
  var midLat = (${g.lat} + ${solutionLat}) / 2;
  var midLng = (${g.lng} + ${solutionLng}) / 2;

  // HTML-Element für die Distanzanzeige erstellen
  var labelDiv = document.createElement('div');

  // UI-Styling: gut lesbar auf dunkler Karte / über der Linie
  labelDiv.style.fontSize = '14px';
  labelDiv.style.fontWeight = 'bold';
  labelDiv.style.color = '#fff';
  labelDiv.style.textShadow = '0 0 2px #000, 0 0 1px #000';
  labelDiv.style.padding = '2px 4px';
  labelDiv.style.borderRadius = '4px';
  labelDiv.style.background = 'rgba(24,29,35,0.7)';

  // Text setzen (auf 2 Nachkommastellen gerundet)
  labelDiv.innerText = dist.toFixed(2) + ' km';

  // OverlayView: erlaubt HTML-Elemente pixelgenau über der Google Map zu platzieren
  var label = new google.maps.OverlayView();

  // Overlay in die passende Map-Ebene einhängen
  label.onAdd = function() {
    var panes = this.getPanes();
    panes.overlayImage.appendChild(labelDiv);
  };

  // draw(): wird von Google Maps aufgerufen, sobald Projektion/Zoom bekannt ist
  // Hier wird Lat/Lng (Mittelpunkt) in Pixelposition umgerechnet
  label.draw = function() {
    var projection = this.getProjection();
    var pos = projection.fromLatLngToDivPixel(new google.maps.LatLng(midLat, midLng));

    // Label mittig auf die Linie setzen
    labelDiv.style.left = pos.x + 'px';
    labelDiv.style.top = pos.y + 'px';
    labelDiv.style.position = 'absolute';
    labelDiv.style.transform = 'translate(-50%, -50%)';
  };

  // Overlay aktivieren, Label wird angezeigt
  label.setMap(map);
})();
\end{lstlisting}

\paragraph{Zoom Animationen}
\mbox{}\\
Um dem Spieler nach Abschluss einer Runde ein besseres visuelles Feedback zu geben, wird in den Einzelspieler-Modi eine Zoom-Animation verwendet. Dabei startet die Ergebnis-Karte bewusst mit einem sehr weit herausgezoomten Kartenbild (Zoom-Level 3) und zoomt anschließend schrittweise auf ein zuvor berechnetes, optimales Zoom-Level "targetZoom" heran. Diese Animation sorgt dafür, dass die Ergebnisansicht dynamischer wirkt und die Aufmerksamkeit des Spielers auf die relevante Region gelenkt wird.

Der folgende Codeausschnitt zeigt die technische Umsetzung dieser Zoom-Animation:

\begin{lstlisting}
// Zoom-Animation (Einzelspieler)
// Startet weit herausgezoomt und zoomt schrittweise bis zum optimalen Zoom-Level (targetZoom)
var currentZoom = 3;

// Intervall steuert die Zoom-Schritte -> kleine Inkremente sorgen für eine flüssige Animation
var zoomInterval = setInterval(function() {

  // Solange der aktuelle Zoom kleiner als das Ziel ist, wird in kleinen Schritten gezoomt
  if (currentZoom < ${targetZoom}) {
    currentZoom += 0.2;      // kleiner Zoom-Schritt für "smooth" Effekt
    map.setZoom(currentZoom);
  } else {
    // Endzustand: Zielzoom setzen und Intervall beenden
    map.setZoom(${targetZoom});
    clearInterval(zoomInterval);
  }

}, 40); // Aktualisierung alle 40ms -> ergibt eine sichtbare, aber nicht hektische Animation
\end{lstlisting}

Im Mehrspieler-Modus wird hingegen bewusst auf eine Zoom-Animation verzichtet. Stattdessen wird die Karte mit einem fixen Zoom-Level (Zoom 7) initialisiert und auf die korrekte Lösung zentriert. Der Grund dafür ist, dass im Mehrspieler-Modus mehrere Pins gleichzeitig sichtbar sein müssen. Ein fixer Zoom-Level bietet hier eine konsistente und faire Darstellung, da alle Spieler dieselbe Kartenansicht erhalten und nicht durch individuelle Zoom-Animationen oder unterschiedliche Bildausschnitte beeinflusst werden.

Der folgende Codeausschnitt zeigt die Initialisierung der Ergebnis-Karte im Mehrspieler-Modus:

\begin{lstlisting}
function initMap() {
  // Mehrspieler: fester Zoom und Zentrierung auf die korrekte Position,
  // damit möglichst viele Spieler-Pins gleichzeitig sichtbar bleiben
  var map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: ${solutionLat}, lng: ${solutionLng} }, // Fokus auf der Lösung
    zoom: 7,                                              // fixer Zoom-Level ohne Animation

    // Deaktivierte Controls, um UI-Überladung zu vermeiden (WebView-optimiert)
    streetViewControl: false,
    mapTypeControl: false,
    fullscreenControl: false,
    backgroundColor: '#181d23',
  });
}
\end{lstlisting}



\paragraph{Darstellung von roten Begrenzungslinien der Bundesländer}
\mbox{}\\
Um dem Spieler die Orientierung im Bundesländer-Modus zu erleichtern, wurde es als notwendig erachtet, die ausgewählten Regionen direkt auf der Karte hervorzuheben. In der fertigen Applikation geschieht dies durch rote Begrenzungslinien, welche die jeweiligen Bundesländer umrahmen. Diese Visualisierung ermöglicht es auch Spielern ohne detaillierte geografische Kenntnisse, ihre Schätzung deutlich zu verbessern. Aber auch für Spieler, die grundsätzlich wissen, wo sich die einzelnen Bundesländer befinden, erweist sich diese Funktion als hilfreich, da die exakten Grenzen eines Bundeslandes meist nicht positionsgenau bekannt sind. Im folgenden Codeabschnitt wird die technische Umsetzung dieser Begrenzungslinien erkärt:
\begin{lstlisting}
/**
 * Zeichnet die Bundesland-Grenzen als rote Linien (Polyline) auf die Google Map.
 * Wichtig: Es werden nur die zuvor ausgewählten Bundesländer visualisiert.
 */
function drawBundeslandBorders(map: google.maps.Map, polygons: number[][][]) {
  // polygons = Array von Polygonen
  // Jedes Polygon besteht aus Koordinatenpaaren: [ [lat, lng], [lat, lng], ... ]
  polygons.forEach(function (poly) {
    // Google Maps erwartet ein Array aus Objekten: { lat: ..., lng: ... }
    var path = poly.map(function (coord) {
      return { lat: coord[0], lng: coord[1] };
    });

    // Polyline = Linie entlang eines Pfades
    // -> wird hier verwendet, um die Grenzen eines Bundeslandes als "Umrandung" darzustellen
    new google.maps.Polyline({
      path: path,           // Koordinaten der Grenze
      geodesic: true,       // Linien folgen der Erdkrümmung (optisch besser)
      strokeColor: '#e53935', // Rot = klare Hervorhebung der Region
      strokeOpacity: 0.8,   // leicht transparent, damit Map darunter sichtbar bleibt
      strokeWeight: 3,      // Linienstärke 
      map: map              // Linie wird auf dieser Map gerendert
    });
  });
}
\end{lstlisting}
Die Datenstruktur "bundeslandPolygone" enthält die geografischen Koordinaten, welche zur Darstellung der Umrandungen der einzelnen Bundesländer auf der Karte verwendet werden. Diese Koordinaten wurden zuvor definiert und werden, abhängig von der Auswahl des Nutzers, an den nächsten Screen übergeben und dort, wie im vorherigen Codeabschnitt zu sehen ist, in der Variable "polygons" gespeichert.
Im folgenden Codeausschnitt ist beispielhaft die Koordinatenliste von Niederösterreich dargestellt:
\begin{lstlisting}
const bundeslandPolygone: Record<string, [number, number][]> = {
  NO: [
    [47.95043408875506, 14.698762389554815],
    [48.04048385766521, 14.493588517608657],
    [48.0878393614031, 14.497187229454624],
    [48.12096875315342, 14.532637250068547],
    [48.20605344194789, 14.529151825814978],
    [48.13279233397873, 14.677843400566644],
    [48.18005034986112, 14.886808802911872],
    [48.18239101457331, 14.985913985326505],
    [48.304748259294826, 15.03844688637082],
    [48.415081911383, 14.981536059098602],
    [48.50897072679291, 14.942687713157738],
    [48.57682310564124, 14.804633727442479],
    [48.57444569787205, 14.730313069995304],
    [48.754971906629066, 14.847549984635009],
    [48.74328857607554, 15.010377026109552],
    [48.98316505291146, 15.035166732418219],
    [48.915680232253266, 15.151922015755076],
    [48.95528574295173, 15.353773338458296],
    [48.827463063435516, 15.736416858341272],
    [48.741442497430484, 16.041584112677526],
    [48.70178743119368, 16.424311052787374],
    [48.77654404657986, 16.484534280952232],
    [48.72046721749055, 16.661585367331924],
    [48.68080673636325, 16.87794422819138],
    [48.54497898198545, 16.902811649140062],
    [48.43930656285778, 16.807056674624505],
    [48.31461656248416, 16.82489987776981],
    [48.15415429562228, 16.941804329225448],
    [48.130510388421044, 17.048035769294103],
    [48.121053326034115, 16.952405246904448],
    [48.07373261573372, 16.945315266729835],
    [48.09265815965756, 16.874359813011807],
    [48.026354014497485, 16.67581082085428],
    [47.9599829134126, 16.62991311827875],
    [47.9647208435928, 16.473859220437845],
    [47.87688916624248, 16.335610387682408],
    [47.817748893194164, 16.278465657273216],
    [47.79007786893314, 16.253704101880118],
    [47.763156131782125, 16.28094225992274],
    [47.496294505025645, 16.29923886354169],
    [47.44381143665282, 16.19010461336819],
    [47.52386921515466, 16.13662614999234],
    [47.54110508792468, 15.992231200396532],
    [47.78375382430232, 15.638270666008367],
    [47.854614627824304, 15.33725551545814],
    [47.76287919408628, 15.020020526653667],
    [47.76076010112098, 14.780838637342981],
    [47.88793707248817, 14.805866778264516],
    [47.927807506465285, 14.738062011740425],
    [47.9422613813521, 14.732092715765788],
    [47.94996567198578, 14.698262079732615],
    [47.950482563098234, 14.69863839164995]
  ],...} 
\end{lstlisting}

\paragraph{Kompass in der Spielansicht}
\mbox{}\\
Der Kompass in der Spielansicht ist ein wichtiges UI-Feature, weil er dem Spieler jederzeit Orientierung gibt und die Street-View-Perspektive lesbarer macht. Da sich die Kamera in Google Street View frei drehen lässt, liefert der Kompass eine direkte Rückmeldung über die Blickrichtung (Heading) und verhindert, dass sich Nutzer beim Erkunden oder beim Platzieren eines Tipps verlaufen. Zusätzlich erhöht das Feature die Immersion, weil es die reale Blickrichtung aus Street View in ein klares, spieltypisches Overlay übersetzt, ein kleines Detail, das sich für den Nutzer aber als hilfreich darstellt und das Gameplay spürbar verbessert.
\begin{lstlisting}
import React, { useEffect, useMemo, useRef, useState } from "react";
import { View, StyleSheet, Animated } from "react-native";
import Svg, { Circle, Line, Text as SvgText } from "react-native-svg";

/**
 * CompassOverlay
 * - heading kommt aus StreetView (pov.heading)
 * - der Kompass wird als Overlay gezeichnet (SVG)
 * - die Nadel (bzw. das ganze Kompass-Element) wird via Animated Rotation gedreht
 */
export function CompassOverlay(props: { heading: number }) {
  const { heading } = props;

  // Animated Wert, der die aktuelle Rotation (in Grad) hält
  const rotation = useRef(new Animated.Value(0)).current;

  // Wir merken uns den zuletzt dargestellten Winkel, um den kürzesten Drehweg zu finden
  const lastHeadingRef = useRef(0);

  useEffect(() => {
    // StreetView liefert heading als Zahl, wir normalisieren auf 0...360
    const next = normalizeAngle(heading);
    const prev = normalizeAngle(lastHeadingRef.current);

    const shortestNext = shortestAngleTarget(prev, next);

    // Animation zur neuen Rotation
    Animated.timing(rotation, {
      toValue: shortestNext,
      duration: 120,          
      useNativeDriver: true,  // Rotation kann nativ laufen, ergibt angenehme Animation
    }).start();

    // lastHeading updaten (wichtig fürs nächste Update)
    lastHeadingRef.current = shortestNext;
  }, [heading, rotation]);

  /**
   * Animated.Value -> String für transform rotate
   * Wir geben "deg" aus, weil RN rotate einen String erwartet.
   */
  const rotate = rotation.interpolate({
    inputRange: [-3600, 3600], // großzügig, weil shortestNext auch mal über 360 hinausgehen kann
    outputRange: ["-3600deg", "3600deg"],
  });

  return (
    <View style={styles.compassOverlay} pointerEvents="none">
      <View style={styles.compassCircle}>
        {/* Wir drehen das ganze SVG, damit die Nadel "mitgeht" */}
        <Animated.View style={{ transform: [{ rotate }] }}>
          <Svg width={56} height={56} viewBox="0 0 56 56">
            {/* Außenring */}
            <Circle
              cx={28}
              cy={28}
              r={26}
              stroke="#fff"
              strokeWidth={2}
              fill="rgba(30,40,80,0.7)"
            />

            {/* Rote Nadel: Norden (zeigt im SVG "nach oben") */}
            <Line
              x1={28}
              y1={28}
              x2={28}
              y2={10}
              stroke="red"
              strokeWidth={4}
              strokeLinecap="round"
            />

            {/* Weiße Nadel: Süden (zeigt im SVG "nach unten") */}
            <Line
              x1={28}
              y1={28}
              x2={28}
              y2={46}
              stroke="#fff"
              strokeWidth={4}
              strokeLinecap="round"
            />

            {/* Labels */}
            <SvgText
              x={28}
              y={7}
              fill="#fff"
              fontSize={12}
              fontWeight="bold"
              textAnchor="middle"
            >
              N
            </SvgText>

            <SvgText
              x={28}
              y={54}
              fill="#fff"
              fontSize={12}
              fontWeight="bold"
              textAnchor="middle"
            >
              S
            </SvgText>
          </Svg>
        </Animated.View>
      </View>
    </View>
  );
}

/**
 * Winkel in den Bereich 0..360 bringen
 */
function normalizeAngle(deg: number) {
  const x = deg % 360;
  return x < 0 ? x + 360 : x;
}

/**
 * Gibt ein Ziel zurück, das vom aktuellen Winkel aus den kürzesten Drehweg nimmt.
 * Dadurch läuft die Animation glatt und ohne Sprünge.
 */
function shortestAngleTarget(prev: number, next: number) {
  let delta = next - prev;

  if (delta > 180) delta -= 360;
  if (delta < -180) delta += 360;

  return prev + delta;
}

const styles = StyleSheet.create({
  // Positionierung als Overlay (z.B. oben links)
  compassOverlay: {
    position: "absolute",
    top: 64,
    left: 16,
    zIndex: 1000,
  },
  // Kreis-Container (Hintergrund + Rundung)
  compassCircle: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: "rgba(30,40,80,0.0)", // SVG hat schon fill, kann hier auch 0 sein
    alignItems: "center",
    justifyContent: "center",
  },
});

\end{lstlisting}

\subsection{Backend-Anbindung mit Supabase}
Das Backend der Anwendung \textit{WoSamma} basiert auf Supabase und stellt zentrale Server-Funktionalitäten als \textit{Backend-as-a-Service} bereit. 
Dadurch werden Kernaufgaben wie Authentifizierung, Datenpersistenz sowie Echtzeit-Kommunikation über eine konsistente API abstrahiert. 
Die mobile Anwendung kommuniziert über das Supabase-SDK mit der PostgreSQL-Datenbank und nutzt dabei eine tokenbasierte Zugriffskontrolle. 
Schreib- und Leseoperationen erfolgen ausschließlich innerhalb der durch Supabase bereitgestellten Sicherheitsmechanismen (z.\,B. JWT-basierte Sessions und Row Level Security), wodurch eine klare Trennung zwischen Client-Logik und serverseitiger Datenhaltung gewährleistet wird.

\subsubsection{Echtzeit-Kommunikation über Supabase Channels}
Die Übertragung von Echtzeitdaten erfolgt über sogenannte \emph{Channels}, die als persistente Kommunikationskanäle zwischen Client und Backend fungieren. 
Diese Kanäle können von der Anwendung abonniert (\textit{subscribed}) werden, um Datenbankereignisse oder benutzerdefinierte Nachrichten unmittelbar zu empfangen.

Technisch basiert dieses Verfahren auf WebSocket-Verbindungen, über die Supabase Änderungen an ausgewählten Tabellen oder spezifische Ereignistypen in nahezu Echtzeit an alle verbundenen Clients verteilt. 
Die Anwendung registriert sich dabei auf bestimmten Channels, die jeweils an einen fachlichen Kontext gebunden sind, beispielsweise an eine Lobby, eine Benutzer-ID oder eine Spielrunde.

Durch dieses Publish-Subscribe-Modell wird eine latenzarme und skalierbare Synchronisation zwischen mehreren Benutzern ermöglicht. 
Dies ist insbesondere für interaktive Funktionen wie Live-Einladungen, Mehrspieler-Lobbys und Chat-Kommunikation von zentraler Bedeutung, da Zustandsänderungen ohne explizite Polling-Mechanismen unmittelbar in der Benutzeroberfläche reflektiert werden.

\begin{lstlisting}
// Initialisierung einer Realtime-Subscription für die Tabelle "friend_requests"
// Zweck dieses Codes ist es, die Freundesliste und die Freundschaftsanfragen
// in der Benutzeroberfläche in Echtzeit zu synchronisieren. Dadurch werden
// Änderungen wie das Hinzufügen, Annehmen oder Entfernen von Freunden sofort
// sichtbar, ohne dass die Ansicht manuell neu geladen werden muss.
subscription = supabase.channel('friend-requests-realtime')
  .on(
    'postgres_changes',
    {
      // Reaktion auf alle relevanten Datenbankereignisse (INSERT, UPDATE, DELETE),
      // um jede Statusänderung einer Freundschaftsanfrage zu erfassen
      event: '*',

      // Angabe des Datenbankschemas, in dem die Beziehungstabelle liegt
      schema: 'public',

      // Ziel-Tabelle, die Freundschaftsanfragen und Beziehungsstatus speichert
      table: 'friend_requests'
    },
    // Callback-Funktion, die bei jeder erkannten Änderung ausgeführt wird
    () => {
      // Neuladen der Freundesliste, um neu hinzugefügte oder entfernte Freunde
      // unmittelbar in der Benutzeroberfläche darzustellen
      fetchFriends(user.id);

      // Aktualisierung aller offenen und eingehenden Freundschaftsanfragen,
      // sodass angenommene oder abgelehnte Anfragen sofort korrekt angezeigt werden
      fetchRequests(user.id);

      // Synchronisation aller bestehenden Beziehungen, um den globalen
      // Beziehungszustand (accepted, pending, declined) konsistent zu halten
      fetchAllRelations(user.id);
    }
  )
  // Aktivierung des Realtime-Kanals und Start des kontinuierlichen Empfangs
  // von Datenbankereignissen für die Live-Aktualisierung der Benutzeransicht
  .subscribe();
\end{lstlisting}

\subsubsection{Authentifizierung der Benutzer (Supabase Auth, OAuth2)}
Die Authentifizierung erfolgt über Supabase Auth als zentrales Identitäts- und Sitzungsmanagement. 
Supabase übernimmt dabei insbesondere die Verwaltung von Benutzer-Sessions, die Erstellung und Validierung von JSON Web Tokens (JWT), das Handling von Refresh-Tokens sowie sicherheitsrelevante Funktionen wie Passwort-Hashing (bei E-Mail/Passwort-Login) und die Integration externer OAuth-Provider.

\paragraph{Laden von Benutzer- und Profildaten: }
Nach erfolgreicher Authentifizierung wird die eindeutige \texttt{user.id} aus der Supabase-Session extrahiert und als primärer Schlüssel für benutzerspezifische Abfragen verwendet. 
Darauf basierend werden Profildaten (z.\,B. Benutzername, Avatar) aus einer \texttt{profiles}-Tabelle geladen und im lokalen Zustand der Anwendung gehalten, um personalisierte Inhalte und Spielzustände konsistent darstellen zu können.

\paragraph{Logout: }
Der Logout erfolgt über \texttt{supabase.auth.signOut()}, wodurch die Session invalidiert und gespeicherte Tokens entfernt werden. 
Zusätzlich wird der lokale Session-Speicher geleert und der Benutzer in den Login-Bereich der Anwendung zurückgeführt, um einen konsistenten und sicheren Zustand sicherzustellen.

\paragraph{Sicherheitsaspekte: }
Die Übertragung der Tokens erfolgt verschlüsselt über TLS. 
Google übernimmt im OAuth2-Flow die Identitätsprüfung des Benutzers; Supabase prüft anschließend die Gültigkeit und Signatur der Tokens bei jeder autorisierten Anfrage. 
Darüber hinaus schützt Row Level Security (RLS) auf Datenbankebene benutzerspezifische Datensätze vor unautorisierten Zugriffen, indem Abfragen und Mutationen nur innerhalb der durch Policies definierten Rechte möglich sind. 
Im OAuth-basierten Verfahren werden keine Passwörter in der Anwendung gespeichert oder verarbeitet.

\subsection{Spielmechanik und Logik}
Dieser Abschnitt beschreibt die grundlegende Spielmechanik von \textit{WoSamma}.
Dabei wird erläutert, wie Spielrunden erstellt werden, wie Mehrspieler-Partien
mit Freunden umgesetzt sind und nach welchen Kriterien die Punktevergabe erfolgt.

\subsubsection{Generierung der Spielrunden}

Die Generierung der Spielrunden im Einzelspieler-Modus \emph{„Ganz Österreich“} basiert auf der zufälligen Auswahl einer geografischen Position innerhalb der Landesgrenzen Österreichs. 
Hierzu wird die Staatsgrenze als Polygon modelliert, das durch eine sequenzielle Liste von Breiten- und Längengraden beschrieben wird:
\begin{lstlisting}
const austriaPolygon = [
  [47.441885, 13.070504],
  [47.657838, 13.179834],
  [47.755772, 13.020078],
  [47.882686, 13.070962],
  [48.096828, 12.838373],
  ...
  [47.447035, 12.895931],
  [47.442109, 13.077460],
  [47.491624, 13.099476]
];
\end{lstlisting}
Dieses Polygon definiert den zulässigen Suchraum für die Erzeugung gültiger Zielkoordinaten.

\paragraph{Punkt-in-Polygon-Prüfung: }
Zur Überprüfung, ob eine zufällig generierte Koordinate innerhalb des definierten Polygons liegt, wird der Ray-Casting-Algorithmus eingesetzt. 
Dabei wird von der zu prüfenden Position aus ein horizontaler Strahl konstruiert und die Anzahl der Schnittpunkte dieses Strahls mit den Polygonkanten bestimmt. 
Ist die Anzahl der Schnittpunkte ungerade, befindet sich der Punkt innerhalb des Polygons; ist sie gerade, liegt der Punkt außerhalb. 
Diese Methode gewährleistet eine effiziente und robuste Klassifikation der Koordinaten in Bezug auf die Landesgrenzen.

\paragraph{Zufällige Koordinatenerzeugung: }
Die Generierung einer Spielrunde erfolgt durch wiederholte Erzeugung zufälliger Koordinaten innerhalb eines umschließenden Rechtecks (Bounding Box), das die maximalen und minimalen Breiten- und Längengrade Österreichs abdeckt. 
Für jede generierte Position wird anschließend mittels der Punkt-in-Polygon-Prüfung verifiziert, ob sich diese innerhalb der tatsächlichen Landesgrenze befindet. 
Nur gültige Koordinaten werden als Zielposition für eine Spielrunde akzeptiert.

\paragraph{Abbruchbedingung und Robustheit: }
Um eine potenziell unendliche Schleife bei ungünstigen Zufallskonstellationen zu vermeiden, ist eine maximale Anzahl von Iterationen definiert. 
Wird diese Grenze überschritten, wird die Generierung abgebrochen und der zuletzt berechnete Wert zurückgegeben. 
Diese Maßnahme stellt die Stabilität der Anwendung sicher und verhindert eine Blockierung des Spielablaufs.

\subsubsection{Generierung des täglichen Spiels}

Das tägliche Spiel wird bei jedem Start der Anwendung initial geprüft und gegebenenfalls neu erzeugt. 
Hierzu wird zunächst eine Abfrage an das Backend durchgeführt, um festzustellen, ob für das aktuelle Kalenderdatum bereits eine gültige Spielrunde in der Datenbank existiert. 
Diese Prüfung erfolgt anhand eines datumsbasierten Identifikators, der sicherstellt, dass pro Tag genau eine eindeutige Zielposition verwendet wird.

Ist kein Eintrag für den aktuellen Tag vorhanden, wird die Zielkoordinate nach demselben Verfahren generiert wie im Einzelspieler-Modus. 
Dabei wird eine zufällige Position innerhalb der definierten Landesgrenzen Österreichs erzeugt und mittels Punkt-in-Polygon-Prüfung validiert. 
Die validierte Koordinate wird anschließend zusammen mit Metadaten (z.\,B. Erstellungsdatum, Runden-ID und Spieltyp) persistent in der Datenbank gespeichert.

Existiert bereits ein tägliches Spiel für den aktuellen Tag, wird die gespeicherte Zielposition aus der Datenbank geladen und für alle Spieler identisch verwendet. 
Durch dieses Vorgehen wird gewährleistet, dass alle Teilnehmer eines Tages unter denselben Bedingungen spielen und die Vergleichbarkeit der Ergebnisse sowie die Integrität der Ranglisten sichergestellt sind.

\subsubsection{Live-Einladungen für Freundesrunden}

Der folgende Code implementiert eine globale Echtzeit-Subscription für Lobby-Einladungen. 
Sobald eine neue Einladung für den eingeloggten Benutzer in der Datenbank erstellt wird, 
erscheint automatisch ein Popup mit den relevanten Lobby- und Einladungsinformationen.
\begin{lstlisting}
useEffect(() => {
  // Vorbedingung:
  // Abbruch der Ausführung, falls keine Benutzer-ID vorhanden ist,
  // da in diesem Fall keine personalisierten Einladungen verarbeitet werden können.
  if (!userId) return;

  // Ressourcenverwaltung:
  // Referenz auf das Realtime-Subscription-Objekt zur späteren Deregistrierung.
  let subscription: any;

  // Initialisierung:
  // Startet die Echtzeit-Überwachung für neue Lobby-Einladungen.
  async function subscribeInvites() {
    // Kanalaufbau:
    // Erstellung eines Supabase-Realtime-Kanals, der auf neue Einträge
    // in der Tabelle "lobby_invites" für den aktuellen Benutzer reagiert.
    subscription = (supabase.channel('global-lobby-invites-' + userId) as any)
      .on(
        'postgres_changes',
        {
          // Ereignistyp:
          // Reaktion ausschließlich auf das Einfügen neuer Datensätze.
          event: 'insert',

          // Schema:
          // Angabe des relevanten Datenbankschemas.
          schema: 'public',

          // Ziel:
          // Tabelle, die die Einladungen zu Mehrspieler-Lobbys enthält.
          table: 'lobby_invites',

          // Filter:
          // Einschränkung auf Einladungen, die an den aktuell angemeldeten Benutzer gerichtet sind.
          filter: `invited_user_id=eq.${userId}`
        },
        // Callback:
        // Wird ausgeführt, sobald eine neue Einladung empfangen wird.
        async (payload: any) => {
          // Datenextraktion:
          // Auslesen des neu eingefügten Einladungseintrags aus dem Ereignisobjekt.
          const invite = payload.new;

          // Datenabfrage:
          // Parallelisierte Abfrage der zugehörigen Lobby-Informationen
          // sowie des Benutzernamens des einladenden Spielers.
          const [{ data: lobby }, { data: inviter }] = await Promise.all([
            supabase.from('lobbies')
              .select('name, code')
              .eq('id', invite.lobby_id)
              .single(),
            supabase.from('profiles')
              .select('username')
              .eq('id', invite.invited_by)
              .single(),
          ]);

          // UI-Aktualisierung:
          // Setzt den lokalen Zustand zur Anzeige des Einladungs-Popups
          // mit allen relevanten Informationen für den Benutzer.
          setInvitePopup({
            id: invite.id,
            lobbyId: invite.lobby_id,
            lobbyName: lobby?.name || 'Lobby',
            lobbyCode: lobby?.code || '',
            inviterName: inviter?.username || 'Ein Freund',
          });

          // Visualisierung:
          // Einblendung des Popups mittels Animation zur Verbesserung der Benutzererfahrung.
          Animated.timing(popupAnim, {
            toValue: 0,
            duration: 350,
            useNativeDriver: true
          }).start();
        }
      )
      // Aktivierung:
      // Startet den Realtime-Kanal und beginnt mit dem Empfang von Ereignissen.
      .subscribe();
  }

  // Initialaufruf:
  // Start der Echtzeit-Überwachung nach dem Initialisieren der Komponente.
  subscribeInvites();

  // Aufräumroutine:
  // Wird beim Verlassen der Komponente ausgeführt, um die
  // Realtime-Verbindung ordnungsgemäß zu schließen und Ressourcen freizugeben.
  return () => {
    if (subscription) supabase.removeChannel(subscription);
  };
}, [userId]);
\end{lstlisting}
\subsubsection{Punkteberechnung}

In diesem Abschnitt wird die Berechnung der Punktzahl im Einzelspieler-Modus von \textit{WoSamma} detailliert beschrieben. 
Die Punktevergabe basiert auf der Entfernung in Kilometern zwischen der vom Spieler gewählten Position und dem tatsächlichen Standort.

\paragraph{Grundprinzip: }
Die erreichte Punktzahl ist eine monotone, stückweise linear fallende Funktion der Distanz $d$ (in Kilometern) zwischen der vom Spieler gewählten Position und dem tatsächlichen Zielort. 
Mit abnehmender Distanz erhöht sich die Punktzahl entsprechend. 
Negative Punktwerte sind grundsätzlich ausgeschlossen; im speziellen Einzelspieler-Modus \emph{„Ganz Österreich“} wird jedoch bei einer Distanz von mehr als $500\,\text{km}$ eine negative Punktzahl von bis zu $-5000$ Punkten vergeben. 
Diese Maßnahme dient dazu, gezielte Fehlplatzierungen zu verhindern und eine künstliche Erhöhung der Platzierung in der Bestenliste durch zufällige oder absichtlich falsche Eingaben zu unterbinden.

\paragraph{Punktebereiche und Berechnungsformeln: }

\begin{itemize}
  \item \textbf{Perfekter Treffer ($d < 1\,\text{km}$)}\\
  Maximale Punktzahl von \textbf{5000 Punkten}.\\
  \emph{Begründung:} Der Spieler befindet sich nahezu exakt auf der korrekten Position.

  \item \textbf{Sehr nah ($1\,\text{km} \leq d < 10\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 5000 auf 4000 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 5000 - 1000 \cdot \frac{d}{10}
  \]
  \emph{Beispiel:} Bei $d = 5\,\text{km}$ ergibt sich $P(5) = 4500$ Punkte.

  \item \textbf{Nah ($10\,\text{km} \leq d < 100\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 4000 auf 1000 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 4000 - 3000 \cdot \frac{d - 10}{90}
  \]
  \emph{Beispiel:} Bei $d = 55\,\text{km}$ ergibt sich $P(55) = 2500$ Punkte.

  \item \textbf{Weit entfernt ($100\,\text{km} \leq d < 500\,\text{km}$)}\\
  Die Punktzahl sinkt linear von 1000 auf 0 Punkte.\\
  \emph{Formel:}
  \[
    P(d) = 1000 - 1000 \cdot \frac{d - 100}{400}
  \]
  \emph{Beispiel:} Bei $d = 300\,\text{km}$ ergibt sich $P(300) = 500$ Punkte.

  \item \textbf{Sehr weit entfernt ($d \geq 500\,\text{km}$)}\\
  Es werden \textbf{0 Punkte} vergeben.\\
  \emph{Begründung:} Der Tipp liegt außerhalb des definierten Bewertungsbereichs.
\end{itemize}

\begin{lstlisting}
// Distanzberechnung unter Berücksichtigung der Erdkrümmung
// Implementierung der Haversine-Formel zur Bestimmung der Großkreisentfernung
// zwischen zwei geografischen Koordinaten (Breiten- und Längengrad).
// Die berechnete Distanz dient als Grundlage für die anschließende Punkteberechnung.
function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number) {

  // Umrechnung von Gradmaß in Bogenmaß, da trigonometrische Funktionen
  // in JavaScript/TypeScript mit Radiantwerten arbeiten
  const toRad = (deg: number) => (deg * Math.PI) / 180;

  // Mittlerer Erdradius in Kilometern gemäß internationalem Referenzwert
  const R = 6371;

  // Berechnung der Differenzen der Breiten- und Längengrade in Radiant
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);

  // Haversine-Term:
  // Kombination aus Sinus- und Kosinusfunktionen zur Modellierung
  // der sphärischen Geometrie der Erdoberfläche
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);

  // Zentrale Winkelentfernung zwischen den beiden Punkten auf der Erdoberfläche
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  // Berechnung der realen Distanz in Kilometern als Produkt aus
  // Erdradius und zentralem Winkel
  const distance = R * c;

  // Rückgabe der berechneten Distanz, welche anschließend als Eingangsgröße
  // für die Punktefunktion verwendet wird
  return distance;
}
\end{lstlisting}

\subsection{Benutzerprofil}
Dieser Abschnitt beschreibt die Umsetzung des Benutzerprofils innerhalb der Anwendung.
Das Benutzerprofil dient zur Darstellung spielrelevanter Informationen sowie zur Verwaltung
von freigeschalteten Inhalten und individuellen Einstellungen.

\subsubsection{Profilanpassung}
Beim Öffnen des Benutzerprofils werden die gespeicherten Basisdaten des angemeldeten Nutzers aus der Datenbank geladen und im lokalen Zustand der Anwendung initialisiert. 
Hierzu zählen insbesondere der Benutzername, die zugewiesene Rolle sowie individuelle Profileinstellungen. 
Zusätzlich wird ermittelt, welches Profilbild aktuell als aktiv markiert ist und welche Profilbilder dem Benutzer grundsätzlich zur Verfügung stehen beziehungsweise bereits freigeschaltet wurden.

Die Auswahl eines neuen Profilbilds erfolgt über einen konsistenten Aktualisierungsmechanismus. 
Zunächst werden alle bisher als aktiv markierten Profilbilder des Benutzers zurückgesetzt. 
Anschließend wird das neu gewählte Profilbild eindeutig als aktiv gesetzt und persistent in der Datenbank gespeichert. 
Dieses Verfahren stellt sicher, dass zu jedem Zeitpunkt genau ein Profilbild als gültig ausgewählt ist.

Benutzer mit administrativen oder entwicklungsbezogenen Rollen erhalten automatisch Zugriff auf alle verfügbaren Profilbilder. 
Diese Berechtigung wird serverseitig über rollenbasierte Zugriffsregeln realisiert und clientseitig entsprechend visualisiert.

Werden Profildaten geändert, so erfolgt eine zentrale Speicherung der aktualisierten Attribute in der Datenbank. 
Hierzu zählen unter anderem der Benutzername, das Geburtsdatum sowie – sofern vom Authentifizierungssystem unterstützt – E-Mail-Adresse und Zugangsdaten. 
Durch die zentrale Persistenz wird gewährleistet, dass die Änderungen konsistent in allen Ansichten der Anwendung reflektiert werden.

\subsubsection{Kaufen und Freischalten von Profilinhalten}
Der integrierte Shop stellt dem Benutzer alle verfügbaren Profilinhalte, insbesondere Profilbilder und Zubehör, in einer strukturierten Übersicht dar. 
Bereits freigeschaltete Inhalte werden visuell von noch nicht erworbenen Elementen unterschieden, um den aktuellen Besitzstatus transparent darzustellen.

Der Erwerb eines Profilinhalts erfolgt über einen simulierten Kaufprozess ohne Anbindung an ein externes Bezahlsystem. 
Bei Bestätigung des Kaufs wird das ausgewählte Element dem Benutzer dauerhaft in der Datenbank zugeordnet. 
Diese Zuordnung wird in einer Besitzrelation gespeichert, die den Benutzer eindeutig mit den freigeschalteten Inhalten verknüpft.

Nach erfolgreichem Erwerb werden die freigeschalteten Inhalte unmittelbar im Profilbereich verfügbar gemacht und können dort als aktive Darstellungselemente ausgewählt werden. 
Ein vergleichbarer Mechanismus wird für Zubehör verwendet, wobei der Besitzstatus ebenfalls persistent gespeichert und in der Benutzeroberfläche entsprechend visualisiert wird.

Im öffentlichen Profil eines Benutzers wird stets das aktuell aktivierte Profilbild angezeigt. 
Diese Darstellung basiert auf der zuletzt im privaten Profil vorgenommenen Auswahl und gewährleistet eine konsistente Repräsentation des Benutzers innerhalb der Anwendung.


\subsection{Freundesystem}
Das Freundesystem ermöglicht die soziale Interaktion zwischen den Benutzern der Anwendung.
Es dient dazu, Spieler miteinander zu vernetzen, gemeinsame Spielrunden zu starten
und den Austausch innerhalb der Anwendung zu fördern.
\subsubsection{Freundschaftsanfragen}
Die Anwendung stellt eine Suchfunktion zur Verfügung, über die Benutzer gezielt nach anderen Spielern suchen und Freundschaftsanfragen initiieren können. 
Beim Senden einer Anfrage wird in der Datenbank eine neue Beziehung zwischen den beiden Benutzern angelegt und initial mit dem Status \texttt{pending} versehen.

Vor dem Erstellen einer Anfrage erfolgt eine serverseitige Validierung, um sicherzustellen, dass zwischen den beiden Benutzern noch keine bestehende Beziehung vorliegt und dass der Empfänger den Erhalt von Freundschaftsanfragen nicht deaktiviert hat. 
Diese Prüfungen verhindern redundante Einträge und unerwünschte Kontaktaufnahmen.

Eingehende Anfragen werden dem Benutzer in einer konsolidierten Übersicht angezeigt. 
Der Benutzer kann jede Anfrage entweder annehmen oder ablehnen, wodurch der Status der Beziehung entsprechend auf \texttt{accepted} beziehungsweise \texttt{declined} gesetzt wird. 
Die Listen der bestehenden Freundschaften und offenen Anfragen werden über eine Echtzeit-Synchronisation automatisch aktualisiert, sodass Statusänderungen unmittelbar in der Benutzeroberfläche reflektiert werden.

\subsubsection{Herausfordern von Freunden}
Ausgehend von der Freundesliste kann ein Benutzer einen direkten Mehrspieler-Vergleich initiieren. 
Hierzu wird eine private Lobby erzeugt, in der der initiierende Benutzer als Host eingetragen wird. 
Der ausgewählte Freund wird über einen Einladungsmechanismus mit dieser Lobby verknüpft.

Zusätzlich wird eine Beitrittsoption bereitgestellt, sofern sich der Freund in einer offenen, öffentlichen Lobby befindet und dort freie Teilnehmerplätze verfügbar sind. 
Einladungen werden als eigenständige Datensätze in der Datenbank geführt und können vom Empfänger explizit angenommen oder abgelehnt werden. 
Dieses Verfahren stellt sicher, dass der Beitritt zu einer Spielrunde stets kontrolliert und nachvollziehbar erfolgt.

\subsubsection{Chatfunktion}
Die Chatfunktion ist als bidirektionale 1-zu-1-Kommunikation zwischen zwei befreundeten Benutzern realisiert. 
Nachrichten werden in einer dedizierten Nachrichtentabelle persistent gespeichert und über Echtzeit-Mechanismen an beide Teilnehmer synchronisiert.

Beim Öffnen eines Chatfensters werden alle vorhandenen Nachrichten beider Benutzer aus der Datenbank geladen. 
Neu eingehende Nachrichten werden unmittelbar in der Benutzeroberfläche angezeigt, wodurch eine kontinuierliche und nahezu verzögerungsfreie Kommunikation ermöglicht wird.

\subsubsection{Anzeigen von Benutzerprofilen}
Benutzerprofile können sowohl aus der Freundesliste als auch aus spielbezogenen Kontexten, wie beispielsweise Lobbys oder Bestenlisten, aufgerufen werden. 
Das öffentliche Profil stellt grundlegende Informationen wie den Benutzernamen, die zugewiesene Rolle sowie ausgewählte statistische Kennzahlen dar.

Darüber hinaus wird das aktuell aktive Profilbild des Benutzers angezeigt. 
Diese Darstellung basiert auf der zuletzt im privaten Profil vorgenommenen Auswahl und gewährleistet eine konsistente Repräsentation des Benutzers über alle Ansichten der Anwendung hinweg.

\subsection{Integration der Google APIs}
In diesem Abschnitt wird die technische Einbindung der externen Google-Dienste beschrieben, die zur Darstellung, Interaktion und Auswertung geografischer Inhalte innerhalb der Anwendung verwendet werden. 
Die Google Maps API und die Google Street View API bilden die visuelle und funktionale Grundlage für die Spielmechanik, indem sie sowohl die kartografische Interaktion als auch die realitätsnahe Darstellung der Spielorte ermöglichen. 
Der Fokus liegt auf der Architektur der Einbindung, der Kommunikation zwischen WebView und nativer Anwendung sowie auf der Validierung und Synchronisation der bereitgestellten Geodaten.

\subsubsection{Verwendung der Google Maps API}
Die Anwendung integriert die Google Maps API zur Darstellung und Interaktion mit geografischen Karteninhalten. 
Der zugehörige API-Schlüssel wird zur Laufzeit aus einer zentralen Konfigurationstabelle im Backend geladen und im Arbeitsspeicher der Anwendung zwischengespeichert. 
Durch dieses Caching wird vermieden, dass der Schlüssel bei jedem Wechsel der Benutzeransicht erneut aus der Datenbank abgerufen werden muss, wodurch sowohl die Netzwerklast als auch die Latenz reduziert werden.

Die Karten werden nicht als native Kartenkomponenten gerendert, sondern als Web-Inhalte in einer \textit{WebView}. 
Hierzu wird dynamisch eine HTML-Seite erzeugt, in die das Google Maps JavaScript SDK eingebunden wird. 
Diese Seite wird innerhalb der mobilen Anwendung ausgeführt und ermöglicht eine plattformunabhängige Nutzung identischer Kartenlogik auf iOS und Android.

Für die Umsetzung der Spielmechanik werden unterschiedliche Kartenvarianten erzeugt, die jeweils auf spezifische Interaktionsszenarien ausgelegt sind. 
Hierzu zählen insbesondere sogenannte \emph{Guess-Karten}, welche das Setzen eines Markers zur Abgabe eines Spieler-Tipps ermöglichen, sowie \emph{Ergebnis-Karten}, die die gewählte Position und den tatsächlichen Zielstandort simultan visualisieren.

Benutzerinteraktionen innerhalb der WebView, wie das Platzieren eines Markers, das Verändern des Zoom- und Kartenfokus oder das Auslösen von Ereignissen, werden über einen Nachrichtenkanal an die native Anwendung zurückgemeldet. 
Diese bidirektionale Kommunikation stellt sicher, dass die Benutzeroberfläche und die zugrunde liegende Spiel- und Auswertungslogik stets synchron zum aktuellen Kartenzustand bleiben.

\subsubsection{Einbindung der Street-View-Bilder}
Die Einbindung der Street-View-Funktionalität erfolgt ebenfalls über das Google Maps JavaScript SDK innerhalb einer WebView. 
Hierbei wird ein Street-View-Panorama erzeugt, das dem Benutzer eine 360-Grad-Ansicht des jeweiligen Spielorts bereitstellt und die visuelle Grundlage für das spielerische Erkundungskonzept bildet.

Zur Reduktion visueller Komplexität werden zentrale Benutzeroberflächenelemente des Street-View-Panoramas, wie beispielsweise Navigations- und Zoom-Steuerelemente, weitgehend ausgeblendet. 
Dadurch wird der Fokus des Benutzers auf die Umgebung und die räumliche Orientierung innerhalb der Spielansicht gelenkt.

Vor der Initialisierung eines Panoramas wird geprüft, ob für die gewünschte Region ein gültiger Street-View-Datenpunkt verfügbar ist. 
Diese Prüfung erfolgt über eine Kombination aus Street-View-Suchanfragen und, falls erforderlich, zusätzlichen Validierungsmechanismen wie regionsbasierten oder polygonalen Verfügbarkeitsprüfungen. 
Wird kein geeigneter Punkt gefunden, wird entweder eine alternative Position gesucht oder dem Benutzer eine entsprechende Fehlermeldung angezeigt.

Die aktuelle Kameraausrichtung des Panoramas (Heading) wird in regelmäßigen Abständen aus der WebView an die native Anwendung übertragen. 
Diese Information wird verwendet, um zusätzliche Overlays, wie beispielsweise einen Kompass, synchron zur Blickrichtung des Benutzers darzustellen und somit eine konsistente und kohärente Benutzererfahrung zu gewährleisten.

